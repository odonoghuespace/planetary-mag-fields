<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planetary Magnetic Field Explorer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        #canvas-container { width: 100vw; height: 100vh; }
        #controls {
            position: fixed;
            top: 50px;
            right: 15px;
            background: rgba(20, 20, 30, 0.9);
            padding: 12px;
            border-radius: 9px;
            min-width: 260px;
            box-shadow: 0 3px 15px rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            z-index: 100;
            font-size: 0.75em;
        }
        h1 {
            font-size: 1.1em;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #planet-title { color: #f0d890; }
        .control-group { margin-bottom: 10px; }
        label { display: block; margin-bottom: 5px; font-size: 0.85em; color: #aaa; }
        .slider-container { display: flex; align-items: center; gap: 8px; }
        input[type="range"] {
            flex: 1;
            appearance: none;
            height: 5px;
            background: #333;
            border-radius: 2px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #f0d890;
            border-radius: 50%;
            cursor: pointer;
        }
        .value-display { min-width: 36px; text-align: right; font-weight: bold; color: #f0d890; }
        .checkbox-group { display: flex; align-items: center; gap: 8px; margin-top: 6px; }
        .checkbox-group input[type="checkbox"] { width: 14px; height: 14px; cursor: pointer; }
        .checkbox-group label { margin: 0; cursor: pointer; color: #ddd; }
        
        .planet-selector {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 12px;
        }
        .planet-btn {
            padding: 6px 12px;
            border: 1px solid #444;
            background: #222;
            color: #aaa;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
        }
        .planet-btn:hover { background: #333; border-color: #666; }
        .planet-btn.active { background: #445; border-color: #88a; color: #fff; }
        .planet-btn.mercury { border-left: 3px solid #888; }
        .planet-btn.earth { border-left: 3px solid #4af; }
        .planet-btn.jupiter { border-left: 3px solid #fa4; }
        .planet-btn.saturn { border-left: 3px solid #a8f; }
        .planet-btn.uranus { border-left: 3px solid #4fa; }
        .planet-btn.neptune { border-left: 3px solid #48f; }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2em;
            color: #f0d890;
            z-index: 200;
            text-align: center;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #333;
            border-top-color: #f0d890;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #info { position: fixed; bottom: 15px; left: 15px; font-size: 0.7em; color: #666; max-width: 300px; }
        #model-info { color: #888; font-size: 0.75em; margin-top: 8px; padding-top: 8px; border-top: 1px solid #333; }
        #scale-note { 
            position: fixed; 
            bottom: 15px; 
            left: 50%; 
            transform: translateX(-50%); 
            font-size: 0.65em; 
            color: #555; 
            font-style: italic; 
            display: none;
        }
        #planet-selector {
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 100;
        }
        #planet-dropdown {
            padding: 8px 12px;
            font-size: 1em;
            background: rgba(20, 20, 30, 0.9);
            color: #f0d890;
            border: 1px solid #444;
            border-radius: 6px;
            cursor: pointer;
            min-width: 140px;
            backdrop-filter: blur(10px);
        }
        #planet-dropdown:hover { border-color: #666; }
        #planet-dropdown option { background: #222; color: #fff; }
        #toggle-controls {
            position: fixed;
            top: 15px;
            right: 15px;
            padding: 6px 12px;
            background: rgba(20, 20, 30, 0.9);
            color: #aaa;
            border: 1px solid #444;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8em;
            z-index: 101;
            backdrop-filter: blur(10px);
        }
        #toggle-controls:hover { background: #333; border-color: #666; color: #fff; }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text">Loading Earth...</div>
    </div>
    
    <div id="planet-selector">
        <select id="planet-dropdown">
            <option value="earth">Earth</option>
            <option value="jupiter">Jupiter</option>
            <option value="saturn">Saturn</option>
            <option value="uranus">Uranus</option>
            <option value="neptune">Neptune</option>
        </select>
    </div>
    
    <button id="toggle-controls">Hide Controls</button>
    
    <div id="controls" style="display: none;">
        <h1><span id="planet-title">Earth Magnetic Field</span></h1>
        
        <div class="control-group">
            <label>L-Shell Value</label>
            <div class="slider-container">
                <input type="range" id="l-slider" min="0" max="27" value="10" step="1">
                <span class="value-display" id="l-value">6.0</span>
            </div>
        </div>
        
        <div class="control-group">
            <label>Longitudes</label>
            <div class="slider-container">
                <input type="range" id="longitude-slider" min="0" max="24" value="8" step="1">
                <span class="value-display" id="longitude-value">8</span>
            </div>
        </div>
        
        <div class="control-group">
            <label>Line Thickness</label>
            <div class="slider-container">
                <input type="range" id="thickness-slider" min="1" max="8" value="2" step="0.5">
                <span class="value-display" id="thickness-value">2</span>
            </div>
        </div>
        
        <div class="control-group">
            <div class="checkbox-group" id="rings-group" style="display: none;">
                <input type="checkbox" id="show-rings" checked>
                <label for="show-rings">Show Rings</label>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="auto-rotate">
                <label for="auto-rotate">Auto Rotate</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="show-tilt">
                <label for="show-tilt" id="tilt-label">Show Axial Tilt (23.4°)</label>
            </div>
            <div class="checkbox-group" id="torus-group" style="display: none;">
                <input type="checkbox" id="show-torus">
                <label for="show-torus" id="torus-label">Show Torus</label>
            </div>
            <div class="checkbox-group" id="flux-tube-group" style="display: none;">
                <input type="checkbox" id="show-flux-tubes" checked>
                <label for="show-flux-tubes">Show Flux Tubes</label>
            </div>
        </div>
        
        <div class="control-group" id="speed-group" style="display: none;">
            <label>Rotation Speed</label>
            <div class="slider-container">
                <input type="range" id="speed-slider" min="0.1" max="10" value="1" step="0.1">
                <span class="value-display" id="speed-value">1.0x</span>
            </div>
        </div>
        
        <div id="model-info"></div>
    </div>
    
    <div id="canvas-container"></div>
    <div id="info">Drag to rotate | Scroll to zoom</div>
    <div id="scale-note">moons not to scale</div>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000008);
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(25, 15, 25);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.getElementById('canvas-container').appendChild(labelRenderer.domElement);
        
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 2;
        controls.maxDistance = 200;
        controls.zoomSpeed = 2.0;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        sunLight.position.set(15, 8, 15);
        scene.add(sunLight);
        const fillLight = new THREE.DirectionalLight(0xffffcc, 0.5);
        fillLight.position.set(-10, -5, -10);
        scene.add(fillLight);
        
        // Flux tube colors for different moons per planet
        // Jupiter: Io=yellow; Saturn: Enceladus=pale blue; Uranus: Miranda/Ariel=purple/cyan
        const PLANET_FLUX_TUBE_COLORS = {
            jupiter: [0xffff00],           // Io = yellow
            saturn: [0x88ccff],            // Enceladus = pale blue
            uranus: [0x8833ff, 0x33ffff],  // Miranda = purple, Ariel = cyan
            neptune: [0x33ff88]            // Triton = green
        };
        const FLUX_TUBE_COLORS = [0xffff00, 0xff8833, 0x8833ff, 0x33ffff];  // fallback
        
        const PLANET_CONFIGS = {
            earth: {
                name: 'Earth',
                fieldColor: 0x44aaff,
                defaultL: 6,
                modelInfo: 'IGRF 2020 model',
                useTexture: 'Earth_Diffuse_1K.jpg'
            },
            jupiter: {
                name: 'Jupiter',
                fieldColor: 0xffaa44,
                defaultL: 30,
                modelInfo: 'JRM33 + Con2020 model'
            },
            saturn: {
                name: 'Saturn',
                fieldColor: 0xaa88ff,
                defaultL: 20,
                modelInfo: 'Cassini 11 model'
            },
            uranus: {
                name: 'Uranus',
                fieldColor: 0x44ffaa,
                defaultL: 10,
                modelInfo: 'GSFC Q3 model'
            },
            neptune: {
                name: 'Neptune',
                fieldColor: 0x4488ff,
                defaultL: 10,
                modelInfo: 'GSFC O8 model'
            }
        };
        
        // State
        let currentPlanet = 'earth';
        let planetData = null;
        let planetMesh = null;
        let ringsMesh = null;
        let moonMeshes = [];
        let moonLabels = [];
        let fluxTubeLines = [];  // Array: one group per moon
        let moonOrbitLines = [];  // Array: orbit circles for each moon
        let auroraParticles = null;  // Aurora particle system
        let fieldLineGroups = new Map();
        let equatorLine = null;
        let northPoleArrow = null;
        let planetGrid = null;  // Planetary grid lines
        let plasmaTorus = null;  // Io torus or Enceladus E-ring
        let autoRotate = false;
        let rotationSpeedMultiplier = 1.0;
        let showFluxTube = true; // Always show flux tubes
        let showAxialTilt = false;
        let showAurora = true;  // Always on
        let showGrid = true;    // Always on
        let showTorus = false;
        let currentLongitudes = 8;
        let currentThickness = 2;
        let planetRotation = 0;
        let moonOrbitAngles = [];
        let L_SHELLS_LOADED = [];
        let tiltGroup = null;  // Group to hold all tilted objects
        
        const textureLoader = new THREE.TextureLoader();
        
        // Debug mode toggle - set to true for extensive logging
        const DEBUG_FLUX_TUBES = true;  // ENABLED for debugging
        
        // Planet texture creation
        function createPlanetTexture(planetKey) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            const textures = {
                earth: () => {
                    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    gradient.addColorStop(0, '#aaddff');
                    gradient.addColorStop(0.15, '#4488cc');
                    gradient.addColorStop(0.5, '#2266aa');
                    gradient.addColorStop(0.85, '#4488cc');
                    gradient.addColorStop(1, '#aaddff');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                },
                jupiter: () => {
                    const bands = [
                        { pos: 0.0, color: '#c4a574' }, { pos: 0.1, color: '#d4b584' },
                        { pos: 0.2, color: '#e8c898' }, { pos: 0.3, color: '#c4a574' },
                        { pos: 0.4, color: '#aa8866' }, { pos: 0.5, color: '#e8c898' },
                        { pos: 0.6, color: '#aa8866' }, { pos: 0.7, color: '#c4a574' },
                        { pos: 0.8, color: '#e8c898' }, { pos: 1.0, color: '#c4a574' }
                    ];
                    for (let y = 0; y < canvas.height; y++) {
                        const t = y / canvas.height;
                        for (let i = 0; i < bands.length - 1; i++) {
                            if (t >= bands[i].pos && t <= bands[i + 1].pos) {
                                ctx.fillStyle = bands[i].color;
                                break;
                            }
                        }
                        ctx.fillRect(0, y, canvas.width, 1);
                    }
                    ctx.fillStyle = 'rgba(180, 80, 60, 0.6)';
                    ctx.beginPath();
                    ctx.ellipse(300, 280, 40, 25, 0, 0, Math.PI * 2);
                    ctx.fill();
                },
                saturn: () => {
                    const bands = [
                        { pos: 0.0, color: '#c4a574' }, { pos: 0.25, color: '#e0c998' },
                        { pos: 0.45, color: '#e8d4a8' }, { pos: 0.5, color: '#f0ddb0' },
                        { pos: 0.55, color: '#e8d4a8' }, { pos: 0.75, color: '#e0c998' },
                        { pos: 1.0, color: '#c4a574' }
                    ];
                    for (let y = 0; y < canvas.height; y++) {
                        const t = y / canvas.height;
                        for (let i = 0; i < bands.length - 1; i++) {
                            if (t >= bands[i].pos && t <= bands[i + 1].pos) {
                                ctx.fillStyle = bands[i].color;
                                break;
                            }
                        }
                        ctx.fillRect(0, y, canvas.width, 1);
                    }
                },
                uranus: () => {
                    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    gradient.addColorStop(0, '#88cccc');
                    gradient.addColorStop(0.5, '#55bbbb');
                    gradient.addColorStop(1, '#88cccc');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                },
                neptune: () => {
                    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    gradient.addColorStop(0, '#4477cc');
                    gradient.addColorStop(0.5, '#2255aa');
                    gradient.addColorStop(1, '#4477cc');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            };
            
            textures[planetKey]();
            
            // Add noise
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                const noise = (Math.random() - 0.5) * 15;
                imageData.data[i] = Math.max(0, Math.min(255, imageData.data[i] + noise));
                imageData.data[i + 1] = Math.max(0, Math.min(255, imageData.data[i + 1] + noise));
                imageData.data[i + 2] = Math.max(0, Math.min(255, imageData.data[i + 2] + noise));
            }
            ctx.putImageData(imageData, 0, 0);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            return texture;
        }
        
        function clearScene() {
            // Clear all flux tube lines BEFORE removing tiltGroup
            fluxTubeLines.forEach(ft => {
                if (ft) {
                    if (ft.geometry) ft.geometry.dispose();
                    if (ft.material) ft.material.dispose();
                    if (tiltGroup) tiltGroup.remove(ft);
                }
            });
            fluxTubeLines = [];
            fluxTubeData = [];
            
            // Remove tiltGroup if exists
            if (tiltGroup) {
                scene.remove(tiltGroup);
                tiltGroup = null;
            }
            
            if (planetMesh) {
                scene.remove(planetMesh);
                planetMesh.geometry.dispose();
                planetMesh.material.dispose();
                planetMesh = null;
            }
            
            if (ringsMesh) {
                scene.remove(ringsMesh);
                ringsMesh.children.forEach(child => {
                    child.geometry.dispose();
                    child.material.dispose();
                });
                ringsMesh = null;
            }
            
            if (equatorLine) {
                scene.remove(equatorLine);
                if (equatorLine.geometry) equatorLine.geometry.dispose();
                if (equatorLine.material) equatorLine.material.dispose();
                equatorLine = null;
            }
            
            if (northPoleArrow) {
                // Remove CSS2D label elements
                northPoleArrow.children.forEach(child => {
                    if (child.element) {
                        child.element.remove();
                    }
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                scene.remove(northPoleArrow);
                northPoleArrow = null;
            }
            
            if (planetGrid) {
                planetGrid.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                scene.remove(planetGrid);
                planetGrid = null;
            }
            
            if (plasmaTorus) {
                if (plasmaTorus.geometry) plasmaTorus.geometry.dispose();
                if (plasmaTorus.material) plasmaTorus.material.dispose();
                scene.remove(plasmaTorus);
                plasmaTorus = null;
            }
            
            moonMeshes.forEach(moon => {
                // Remove labels attached to moon
                moon.children.forEach(child => {
                    if (child.element) {
                        child.element.remove();
                    }
                });
                scene.remove(moon);
                moon.geometry.dispose();
                moon.material.dispose();
            });
            moonMeshes = [];
            moonLabels = [];
            moonOrbitAngles = [];
            
            // Clear moon orbit lines
            moonOrbitLines.forEach(orbitLine => {
                if (orbitLine) {
                    if (orbitLine.geometry) orbitLine.geometry.dispose();
                    if (orbitLine.material) orbitLine.material.dispose();
                    scene.remove(orbitLine);
                }
            });
            moonOrbitLines = [];
            
            // Clear aurora particles
            if (auroraParticles) {
                if (auroraParticles.geometry) auroraParticles.geometry.dispose();
                if (auroraParticles.material) auroraParticles.material.dispose();
                scene.remove(auroraParticles);
                auroraParticles = null;
            }
            
            fieldLineGroups.forEach(group => {
                group.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                scene.remove(group);
            });
            fieldLineGroups.clear();
        }
        
        function createPlanet(data) {
            const oblateness = data.oblateness || 1.0;
            const geometry = new THREE.SphereGeometry(1, 64, 32);
            const positions = geometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                positions.setY(i, positions.getY(i) * oblateness);
            }
            geometry.computeVertexNormals();
            
            const config = PLANET_CONFIGS[currentPlanet];
            let material;
            
            if (config.useTexture) {
                // Load real texture for Earth
                const texture = textureLoader.load(config.useTexture);
                // Rotate texture 180° to align 0° longitude correctly
                texture.offset.x = 0.5;
                texture.wrapS = THREE.RepeatWrapping;
                material = new THREE.MeshStandardMaterial({
                    map: texture,
                    roughness: 0.8,
                    metalness: 0.1
                });
            } else {
                const texture = createPlanetTexture(currentPlanet);
                material = new THREE.MeshStandardMaterial({
                    map: texture,
                    roughness: 0.8,
                    metalness: 0.1
                });
            }
            
            planetMesh = new THREE.Mesh(geometry, material);
            tiltGroup.add(planetMesh);
        }
        
        function createEquator(data) {
            const oblateness = data.oblateness || 1.0;
            // Create equator circle at y=0
            const segments = 128;
            const points = [];
            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                points.push(new THREE.Vector3(
                    Math.cos(theta) * 1.002,  // Slightly outside planet surface
                    0,
                    Math.sin(theta) * 1.002
                ));
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: 0xffff00,
                transparent: true,
                opacity: 0.7
            });
            equatorLine = new THREE.Line(geometry, material);
            tiltGroup.add(equatorLine);
        }
        
        function createNorthPoleArrow(data) {
            const oblateness = data.oblateness || 1.0;
            // flip_north is only used when axial tilt is shown - when tilt is off, north is always up
            const arrowGroup = new THREE.Group();
            
            // Arrow shaft - from south pole through north pole (2x longer, thicker)
            // Total length = 2 * oblateness + 1.0 on each side = covers both poles plus extension
            const shaftLength = oblateness * 2 + 2.0;  // Through planet + 1.0 extension each side
            const shaftGeometry = new THREE.CylinderGeometry(0.04, 0.04, shaftLength, 8);
            const shaftMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
            shaft.position.y = 0;  // Centered at origin
            arrowGroup.add(shaft);
            
            // Arrow head cone - always points up (north) when tilt is off
            // When tilt is on and flip_north is true, the tiltGroup rotation handles it
            const coneGeometry = new THREE.ConeGeometry(0.12, 0.3, 8);
            const coneMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const cone = new THREE.Mesh(coneGeometry, coneMaterial);
            cone.position.y = shaftLength / 2 + 0.15;  // Top of shaft + half cone height
            arrowGroup.add(cone);
            
            // Add "N" label (white) - always at the top
            const labelDiv = document.createElement('div');
            labelDiv.textContent = 'N';
            labelDiv.style.cssText = 'color:#ffffff;font-size:14px;font-weight:bold;text-shadow:0 0 3px #000;';
            const label = new CSS2DObject(labelDiv);
            label.position.set(0, shaftLength / 2 + 0.5, 0);
            arrowGroup.add(label);
            
            northPoleArrow = arrowGroup;
            tiltGroup.add(northPoleArrow);
        }
        
        function createPlanetaryGrid(data) {
            const oblateness = data.oblateness || 1.0;
            const gridGroup = new THREE.Group();
            
            // Create latitude lines (parallels) - every 15 degrees
            const latitudes = [-75, -60, -45, -30, -15, 0, 15, 30, 45, 60, 75];  // degrees
            latitudes.forEach(lat => {
                const latRad = lat * Math.PI / 180;
                const y = Math.sin(latRad) * oblateness;  // Apply oblateness to Y
                const radius = Math.cos(latRad) * 1.01;  // Slightly above surface
                
                const segments = 64;
                const points = [];
                for (let i = 0; i <= segments; i++) {
                    const theta = (i / segments) * Math.PI * 2;
                    points.push(new THREE.Vector3(
                        Math.cos(theta) * radius,
                        y,
                        Math.sin(theta) * radius
                    ));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: lat === 0 ? 0xffff00 : 0xffffff,  // Yellow for equator, white for others
                    transparent: true,
                    opacity: lat === 0 ? 0.7 : 0.4
                });
                const line = new THREE.Line(geometry, material);
                gridGroup.add(line);
            });
            
            // Create longitude lines (meridians)
            const numMeridians = 12;  // Every 30 degrees
            for (let i = 0; i < numMeridians; i++) {
                const lon = (i / numMeridians) * Math.PI * 2;
                const segments = 64;
                const points = [];
                
                for (let j = 0; j <= segments; j++) {
                    const lat = ((j / segments) - 0.5) * Math.PI;  // -90 to +90 degrees
                    const y = Math.sin(lat) * oblateness;
                    const radius = Math.cos(lat);
                    
                    points.push(new THREE.Vector3(
                        Math.cos(lon) * radius * 1.01,
                        y * 1.01,
                        Math.sin(lon) * radius * 1.01
                    ));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.4
                });
                const line = new THREE.Line(geometry, material);
                gridGroup.add(line);
            }
            
            gridGroup.visible = showGrid;
            planetGrid = gridGroup;
            tiltGroup.add(planetGrid);
        }
        
        function createEnceladusERing() {
            // Create Enceladus E-ring for Saturn
            // Inner radius: 3.4 Saturn radii, Outer radius: 4.5 Saturn radii
            // Thickness: 0.5 Saturn radii, Color: electric blue
            const particleCount = 37500;  // 25% more particles
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            const innerRadius = 3.4;
            const outerRadius = 4.5;
            const thickness = 0.5;
            const majorRadius = (innerRadius + outerRadius) / 2;
            const minorRadius = (outerRadius - innerRadius) / 2;
            
            for (let i = 0; i < particleCount; i++) {
                // Random angle around the ring
                const theta = Math.random() * Math.PI * 2;
                
                // Random radius with slightly more even distribution
                const r = majorRadius + (Math.random() - 0.5) * 2 * minorRadius * Math.pow(Math.random(), 0.6);
                
                // Random vertical offset with slightly more even distribution (Y is up)
                const y = (Math.random() - 0.5) * thickness * Math.pow(Math.random(), 0.8);
                
                positions[i * 3] = r * Math.cos(theta);
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = r * Math.sin(theta);
                
                // Electric blue color with slight variation
                const brightness = 0.7 + Math.random() * 0.3;
                colors[i * 3] = 0.2 * brightness;
                colors[i * 3 + 1] = 0.5 * brightness;
                colors[i * 3 + 2] = 1.0 * brightness;
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.015,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            plasmaTorus = new THREE.Points(geometry, material);
            // E-ring is in the equatorial plane (XZ plane), no rotation needed
            plasmaTorus.visible = showTorus;
            tiltGroup.add(plasmaTorus);
        }
        
        function createIoTorus(data) {
            // Create Io plasma torus for Jupiter along magnetic equator
            // Extract magnetic equator from Io flux tubes
            if (!data || !data.moon_flux_tubes || data.moon_flux_tubes.length === 0) return;
            
            const ioFluxData = data.moon_flux_tubes[0]; // First moon (Io)
            if (!ioFluxData || !ioFluxData.radial_samples || ioFluxData.radial_samples.length === 0) return;
            
            const radialSample = ioFluxData.radial_samples[0]; // L-shell data
            if (!radialSample || !radialSample.lines) return;
            
            // Find the furthest point from planet along each flux tube
            const magneticEquatorPoints = [];
            radialSample.lines.forEach(fluxTube => {
                let maxDistance = 0;
                let furthestPoint = null;
                
                fluxTube.forEach(point => {
                    const [x, y, z] = point;
                    const distance = Math.sqrt(x * x + y * y + z * z);
                    if (distance > maxDistance) {
                        maxDistance = distance;
                        furthestPoint = { x, y, z };
                    }
                });
                
                if (furthestPoint) {
                    magneticEquatorPoints.push(furthestPoint);
                }
            });
            
            if (magneticEquatorPoints.length === 0) return;
            
            // Create torus particles along magnetic equator
            const particleCount = 71875;  // 15% more particles (was 62500)
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const thickness = 1.0; // 1 planetary radius thick
            
            for (let i = 0; i < particleCount; i++) {
                // Pick a random point along the magnetic equator
                const idx = Math.floor(Math.random() * magneticEquatorPoints.length);
                const equatorPoint = magneticEquatorPoints[idx];
                
                // Add random offset in a sphere around the equator point
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const distance = Math.random() * thickness * Math.pow(Math.random(), 0.4);  // Slightly more even distribution
                
                const offsetX = distance * Math.sin(phi) * Math.cos(theta);
                const offsetY = distance * Math.sin(phi) * Math.sin(theta);
                const offsetZ = distance * Math.cos(phi);
                
                positions[i * 3] = equatorPoint.x + offsetX;
                positions[i * 3 + 1] = equatorPoint.y + offsetY;
                positions[i * 3 + 2] = equatorPoint.z + offsetZ;
                
                // Red color with variation
                const brightness = 0.6 + Math.random() * 0.4;
                colors[i * 3] = 1.0 * brightness;
                colors[i * 3 + 1] = 0.2 * brightness;
                colors[i * 3 + 2] = 0.15 * brightness;
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.02,
                vertexColors: true,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            plasmaTorus = new THREE.Points(geometry, material);
            plasmaTorus.visible = showTorus;
            tiltGroup.add(plasmaTorus);
        }
        
        function createRings() {
            if (currentPlanet !== 'saturn') return;
            
            const ringsGroup = new THREE.Group();
            const RING_STRUCTURE = [
                { inner: 1.110, outer: 1.236, opacity: 0.15, brightness: 0.3 },
                { inner: 1.239, outer: 1.527, opacity: 0.50, brightness: 0.525 },
                { inner: 1.527, outer: 1.951, opacity: 0.85, brightness: 1.0 },
                { inner: 1.951, outer: 2.023, opacity: 0.05, brightness: 0.15 },
                { inner: 2.023, outer: 2.270, opacity: 0.65, brightness: 0.7 },
                { inner: 2.310, outer: 2.330, opacity: 0.4, brightness: 0.5 },
            ];
            
            RING_STRUCTURE.forEach(ring => {
                const geometry = new THREE.RingGeometry(ring.inner, ring.outer, 128, 1);
                geometry.rotateX(-Math.PI / 2);
                const brightness = Math.floor(ring.brightness * 200 + 55);
                const color = new THREE.Color(`rgb(${brightness}, ${brightness - 20}, ${brightness - 40})`);
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: ring.opacity
                });
                ringsGroup.add(new THREE.Mesh(geometry, material));
            });
            
            ringsMesh = ringsGroup;
            tiltGroup.add(ringsMesh);
        }
        
        function createMoons(data) {
            if (!data.moons || data.moons.length === 0) return;
            
            data.moons.forEach((moon, index) => {
                // Create moon orbit circle using thick lines
                const orbitSegments = 128;
                const orbitPositions = [];
                for (let i = 0; i <= orbitSegments; i++) {
                    const theta = (i / orbitSegments) * Math.PI * 2;
                    orbitPositions.push(
                        Math.cos(theta) * moon.orbit_radius,
                        0,
                        Math.sin(theta) * moon.orbit_radius
                    );
                }
                const orbitGeometry = new LineGeometry();
                orbitGeometry.setPositions(orbitPositions);
                const orbitMaterial = new LineMaterial({ 
                    color: 0x888888,
                    linewidth: 2,
                    transparent: true,
                    opacity: 0.7,
                    resolution: new THREE.Vector2(window.innerWidth, window.innerHeight)
                });
                const orbitLine = new Line2(orbitGeometry, orbitMaterial);
                orbitLine.computeLineDistances();
                tiltGroup.add(orbitLine);
                moonOrbitLines.push(orbitLine);
                
                // Make moons visually 2x thicker than flux tubes
                // Flux tube linewidth is 4 pixels, so moon should be clearly larger
                // Using 0.15 radius makes moons nicely visible compared to flux tube lines
                const moonSize = 0.15;
                const geometry = new THREE.SphereGeometry(moonSize, 16, 16);
                const material = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    roughness: 0.8,
                    emissive: 0x333333
                });
                const moonMesh = new THREE.Mesh(geometry, material);
                moonMesh.position.set(moon.orbit_radius, 0, 0);
                moonMesh.userData = moon;
                moonMesh.userData.displaySize = moonSize;
                tiltGroup.add(moonMesh);
                moonMeshes.push(moonMesh);
                
                const labelDiv = document.createElement('div');
                labelDiv.textContent = moon.name;
                labelDiv.style.cssText = 'color:#fff;font-size:11px;text-shadow:0 0 4px #000;font-weight:bold;';
                const label = new CSS2DObject(labelDiv);
                label.position.set(0, moonSize + 0.1, 0);
                moonMesh.add(label);
                moonLabels.push(label);
                
                moonOrbitAngles.push(0);
            });
        }
        
        function createFieldLines(data) {
            const oblateness = data.oblateness || 1.0;
            
            data.l_shells.forEach((lData) => {
                const L = lData.L;
                const group = new THREE.Group();
                group.visible = false;
                group.userData.L = L;
                group.userData.allLines = lData.lines;
                
                createLinesForGroup(group, currentLongitudes, oblateness);
                
                fieldLineGroups.set(L, group);
                tiltGroup.add(group);
            });
            
            L_SHELLS_LOADED = data.l_shells.map(ls => ls.L);
            
            const slider = document.getElementById('l-slider');
            slider.max = L_SHELLS_LOADED.length - 1;
            
            const config = PLANET_CONFIGS[currentPlanet];
            const defaultL = config.defaultL;
            let defaultIndex = 0;
            for (let i = 0; i < L_SHELLS_LOADED.length; i++) {
                if (L_SHELLS_LOADED[i] >= defaultL) {
                    defaultIndex = i;
                    break;
                }
            }
            slider.value = defaultIndex;
            updateVisibleFieldLines(L_SHELLS_LOADED[defaultIndex]);
            document.getElementById('l-value').textContent = L_SHELLS_LOADED[defaultIndex].toFixed(1);
        }
        
        function extendToSurface(point, oblateness) {
            const x = point[0], y = point[1], z = point[2];
            
            // For an oblate spheroid: x²/a² + y²/b² + z²/a² = 1
            // where a=1 (equatorial) and b=oblateness (polar)
            // We need to find the scale factor s such that:
            // (sx)²/1² + (sy)²/oblateness² + (sz)²/1² = 1
            
            const oblate_sq = oblateness * oblateness;
            const denom = x*x + z*z + (y*y / oblate_sq);
            
            if (denom < 0.001) {
                if (DEBUG_FLUX_TUBES) console.warn('[extendToSurface] Point too close to origin:', point);
                return [x, y, z];
            }
            
            const s = 1.0 / Math.sqrt(denom);
            const extended = [x * s, y * s, z * s];
            
            if (DEBUG_FLUX_TUBES) {
                // Verify the result is on the surface
                const r_check = Math.sqrt(extended[0]*extended[0] + extended[1]*extended[1] + extended[2]*extended[2]);
                const surface_check = extended[0]*extended[0] + extended[2]*extended[2] + (extended[1]*extended[1] / oblate_sq);
                
                console.log(`[extendToSurface] Input: (${x.toFixed(3)}, ${y.toFixed(3)}, ${z.toFixed(3)}), r=${Math.sqrt(x*x+y*y+z*z).toFixed(4)}`);
                console.log(`[extendToSurface] Output: (${extended[0].toFixed(3)}, ${extended[1].toFixed(3)}, ${extended[2].toFixed(3)}), r=${r_check.toFixed(4)}, surface_eq=${surface_check.toFixed(4)} (should be ~1.0)`);
            }
            
            return extended;
        }
        
        function createLinesForGroup(group, numLongitudes, oblateness) {
            while (group.children.length > 0) {
                const child = group.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                group.remove(child);
            }
            
            const L = group.userData.L;
            const allLines = group.userData.allLines;
            if (!allLines || allLines.length === 0) return;
            
            const totalLines = allLines.length;
            
            for (let i = 0; i < numLongitudes; i++) {
                const lineIndex = Math.floor((i * totalLines) / numLongitudes) % totalLines;
                const pointsData = allLines[lineIndex];
                
                if (pointsData && pointsData.length > 5) {
                    const positions = [];
                    
                    const startExt = extendToSurface(pointsData[0], oblateness);
                    positions.push(startExt[0], startExt[1], startExt[2]);
                    
                    for (const p of pointsData) {
                        positions.push(p[0], p[1], p[2]);
                    }
                    
                    const endExt = extendToSurface(pointsData[pointsData.length - 1], oblateness);
                    positions.push(endExt[0], endExt[1], endExt[2]);
                    
                    const geometry = new LineGeometry();
                    geometry.setPositions(positions);
                    
                    const maxL = L_SHELLS_LOADED[L_SHELLS_LOADED.length - 1] || 30;
                    const t = Math.min((L - 1.1) / (maxL - 1.1), 1.0);
                    const color = new THREE.Color();
                    color.setHSL(0.65 - t * 0.65, 1.0, 0.55);
                    
                    const material = new LineMaterial({
                        color: color,
                        linewidth: currentThickness,
                        resolution: new THREE.Vector2(window.innerWidth, window.innerHeight)
                    });
                    
                    const line = new Line2(geometry, material);
                    line.computeLineDistances();
                    group.add(line);
                }
            }
        }
        
        function updateLongitudes(numLongitudes) {
            currentLongitudes = numLongitudes;
            const oblateness = planetData?.oblateness || 1.0;
            fieldLineGroups.forEach((group) => {
                createLinesForGroup(group, numLongitudes, oblateness);
            });
        }
        
        function updateThickness(thickness) {
            currentThickness = thickness;
            fieldLineGroups.forEach((group) => {
                group.children.forEach(child => {
                    if (child.material && child.material.linewidth !== undefined) {
                        child.material.linewidth = thickness;
                    }
                });
            });
        }
        
        function updateVisibleFieldLines(targetL) {
            let closestL = null;
            let closestDist = Infinity;
            
            L_SHELLS_LOADED.forEach(L => {
                const dist = Math.abs(L - targetL);
                if (dist < closestDist) {
                    closestDist = dist;
                    closestL = L;
                }
            });
            
            fieldLineGroups.forEach((group, L) => {
                group.visible = (L === closestL);
            });
        }
        
        // Store flux tube data for each moon - using dedicated high-res moon_flux_tubes data
        // These are fixed in the magnetic field frame (rotate with planet)
        // The moon moves through them as it orbits
        // Data structure: moon_flux_tubes[moonIndex].radial_samples[radialIndex].lines[lonIndex]
        let fluxTubeData = [];  // Array of {radialSamples, numLons, currentIndex, line} per moon
        
        function createFluxTubes(data) {
            if (!data.moons || data.moons.length === 0) return;
            if (!data.moon_flux_tubes || data.moon_flux_tubes.length === 0) {
                console.log('[createFluxTubes] No moon flux tube data found - using legacy l_shells');
                createFluxTubesLegacy(data);
                return;
            }

            const oblateness = data.oblateness || 1.0;
            console.log(`[createFluxTubes] Creating flux tubes for ${data.moon_flux_tubes.length} moons, oblateness=${oblateness.toFixed(3)}`);
            
            data.moon_flux_tubes.forEach((moonFT, moonIndex) => {
                if (!moonFT || !moonFT.radial_samples || moonFT.radial_samples.length === 0) {
                    console.warn(`[createFluxTubes] Moon ${moonIndex}: No radial samples`);
                    fluxTubeLines.push(null);
                    fluxTubeData.push(null);
                    return;
                }
                
                // Use the middle radial sample (closest to actual orbit)
                const midIndex = Math.floor(moonFT.radial_samples.length / 2);
                const primarySample = moonFT.radial_samples[midIndex];
                const numLines = primarySample.lines.length;
                
                // Count valid vs invalid lines
                let validCount = 0, invalidCount = 0;
                primarySample.lines.forEach(l => {
                    if (l && l.length >= 5) validCount++;
                    else invalidCount++;
                });
                console.log(`[createFluxTubes] ${moonFT.moon_name}: ${numLines} longitudes (${validCount} valid, ${invalidCount} invalid)`);
                
                // Create ONE Line2 object per moon - we'll update its geometry dynamically
                const firstValidLine = primarySample.lines.find(l => l && l.length >= 5);
                if (!firstValidLine) {
                    console.error(`[createFluxTubes] ${moonFT.moon_name}: No valid lines found!`);
                    fluxTubeLines.push(null);
                    fluxTubeData.push(null);
                    return;
                }
                
                // Build positions - DON'T extend, data already reaches surface!
                const positions = [];
                
                for (const p of firstValidLine) {
                    positions.push(p[0], p[1], p[2]);  // data is in Three.js coords already
                }
                
                const geometry = new LineGeometry();
                geometry.setPositions(positions);
                
                // Get planet-specific color for this moon
                const planetColors = PLANET_FLUX_TUBE_COLORS[currentPlanet] || FLUX_TUBE_COLORS;
                const tubeColor = planetColors[moonIndex % planetColors.length];
                
                const material = new LineMaterial({
                    color: tubeColor,
                    linewidth: 4,
                    resolution: new THREE.Vector2(window.innerWidth, window.innerHeight),
                    transparent: true,
                    opacity: 0.5,
                    alphaToCoverage: false,
                    depthWrite: false
                });
                
                const fluxTube = new Line2(geometry, material);
                fluxTube.computeLineDistances();
                fluxTube.visible = showFluxTube;
                tiltGroup.add(fluxTube);
                
                fluxTubeLines.push(fluxTube);
                fluxTubeData.push({
                    radialSamples: moonFT.radial_samples,  // All radial samples
                    numLons: numLines,
                    currentLonIndex: -1,
                    currentRadialIndex: midIndex,
                    lastPositions: null
                });
                
                console.log(`[createFluxTubes] ${moonFT.moon_name}: Ready ✓`);
            });
        }
        
        // Legacy function for old data format without moon_flux_tubes
        function createFluxTubesLegacy(data) {
            data.moons.forEach((moon, moonIndex) => {
                const moonOrbit = moon.orbit_radius;
                let closestLData = null;
                let closestDist = Infinity;
                
                for (const lData of data.l_shells) {
                    const dist = Math.abs(lData.L - moonOrbit);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestLData = lData;
                    }
                }
                
                if (!closestLData || !closestLData.lines || closestLData.lines.length === 0) {
                    fluxTubeLines.push(null);
                    fluxTubeData.push(null);
                    return;
                }
                
                const scaleFactor = moonOrbit / closestLData.L;
                const firstValidLine = closestLData.lines.find(l => l && l.length >= 5);
                if (!firstValidLine) {
                    fluxTubeLines.push(null);
                    fluxTubeData.push(null);
                    return;
                }

                // Ensure endpoints reach the oblate planet surface when creating legacy flux tubes
                const oblateness = data.oblateness || 1.0;
                const positions = [];
                const scaledStart = [firstValidLine[0][0] * scaleFactor, firstValidLine[0][1], firstValidLine[0][2] * scaleFactor];
                const startExt = extendToSurface(scaledStart, oblateness);
                positions.push(startExt[0], startExt[1], startExt[2]);

                for (const p of firstValidLine) {
                    positions.push(p[0] * scaleFactor, p[1], p[2] * scaleFactor);
                }

                const scaledEnd = [firstValidLine[firstValidLine.length - 1][0] * scaleFactor, firstValidLine[firstValidLine.length - 1][1], firstValidLine[firstValidLine.length - 1][2] * scaleFactor];
                const endExt = extendToSurface(scaledEnd, oblateness);
                positions.push(endExt[0], endExt[1], endExt[2]);
                
                const geometry = new LineGeometry();
                geometry.setPositions(positions);
                
                // Get planet-specific color for this moon
                const planetColors = PLANET_FLUX_TUBE_COLORS[currentPlanet] || FLUX_TUBE_COLORS;
                const tubeColor = planetColors[moonIndex % planetColors.length];
                
                const material = new LineMaterial({
                    color: tubeColor,
                    linewidth: 4,
                    resolution: new THREE.Vector2(window.innerWidth, window.innerHeight),
                    transparent: true,
                    opacity: 0.5,
                    alphaToCoverage: false,
                    depthWrite: false
                });
                
                const fluxTube = new Line2(geometry, material);
                fluxTube.computeLineDistances();
                fluxTube.visible = showFluxTube;
                tiltGroup.add(fluxTube);
                
                fluxTubeLines.push(fluxTube);
                fluxTubeData.push({
                    rawLines: closestLData.lines,
                    scaleFactor: scaleFactor,
                    numLons: closestLData.lines.length,
                    currentLonIndex: -1,
                    isLegacy: true,
                    lastPositions: null
                });
            });
        }
        
        // Update flux tubes: find the pre-calculated tube closest to moon's current position
        // 
        // COORDINATE SYSTEM:
        // - Moons orbit in equatorial plane: x = r*cos(angle), y = 0, z = r*-sin(angle)
        // - Flux tubes are 3D field lines that pass through the moon's orbital radius
        //   at the equatorial plane (y≈0) but curve out of the plane over the poles
        // - Flux tubes are indexed by the longitude where they cross the equatorial plane
        // - Data is in Three.js coords: [x, z, y] where y is rotation axis (UP)
        //
        // PHYSICS:
        // - Each flux tube is traced from a point at (r*cos(lon), 0, r*sin(lon)) in the 
        //   equatorial plane, following the magnetic field in both directions to the surface
        // - The tube will NOT stay at y=0; it will arc up/down following field lines!
        // - We select the tube by moon's longitude, but the tube extends in 3D
        // - INTERPOLATION: We blend between adjacent longitude samples for smooth animation
        //
        function updateFluxTubes() {
            if (!showFluxTube) {
                fluxTubeLines.forEach(ft => { 
                    if (ft) ft.visible = false; 
                });
                return;
            }
            
            moonMeshes.forEach((moon, moonIndex) => {
                const fluxTube = fluxTubeLines[moonIndex];
                const ftData = fluxTubeData[moonIndex];
                if (!fluxTube || !ftData) {
                    if (DEBUG_FLUX_TUBES) console.warn(`[updateFluxTubes] Moon ${moonIndex}: No flux tube or data`);
                    return;
                }
                
                // Moon's position in the tiltGroup (equatorial plane) frame
                const mx = moon.position.x;
                const my = moon.position.y;  // Should be 0, but let's log it
                const mz = moon.position.z;
                
                // Calculate moon's longitude in equatorial plane (XZ plane, y=0)
                // Moon orbit: x = r*cos(angle), z = -r*sin(angle)
                // Therefore: atan2(z, x) = atan2(-sin, cos) = -angle
                // We want positive angle: longitude = -atan2(z, x) = atan2(-z, x)
                let moonLongitude = Math.atan2(-mz, mx);
                
                // Normalize to 0 to 2π
                moonLongitude = ((moonLongitude % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
                
                // Convert to FRACTIONAL flux tube index for interpolation
                const fractionalIndex = (moonLongitude / (2 * Math.PI)) * ftData.numLons;
                const lonIndex0 = Math.floor(fractionalIndex) % ftData.numLons;
                const lonIndex1 = (lonIndex0 + 1) % ftData.numLons;
                const interpFactor = fractionalIndex - Math.floor(fractionalIndex);  // 0 to 1
                
                if (DEBUG_FLUX_TUBES && (lonIndex0 !== ftData.currentLonIndex || !ftData.lastPositions)) {
                    console.log(`[updateFluxTubes] Moon ${moonIndex} (${moonMeshes[moonIndex]?.userData?.name || 'unknown'}): ` +
                                `pos=(${mx.toFixed(2)}, ${my.toFixed(4)}, ${mz.toFixed(2)}), ` +
                                `moonLon=${(moonLongitude*180/Math.PI).toFixed(1)}°, ` +
                                `lonIdx=${lonIndex0}+${interpFactor.toFixed(3)}/${ftData.numLons}`);
                }
                
                // Always update geometry for smooth interpolation
                ftData.currentLonIndex = lonIndex0;
                
                let lineData0 = null;
                let lineData1 = null;
                const oblateness = planetData?.oblateness || 1.0;
                
                // Helper function to find valid line data with fallback
                function findValidLineData(startIdx, radialSample) {
                    let lineData = radialSample ? radialSample.lines[startIdx] : ftData.rawLines?.[startIdx];
                    if (lineData && lineData.length >= 5) return lineData;
                    
                    // Search for nearest valid neighbor
                    for (let offset = 1; offset <= ftData.numLons / 2; offset++) {
                        const prevIdx = (startIdx - offset + ftData.numLons) % ftData.numLons;
                        const nextIdx = (startIdx + offset) % ftData.numLons;
                        const lines = radialSample ? radialSample.lines : ftData.rawLines;
                        if (lines[prevIdx]?.length >= 5) return lines[prevIdx];
                        if (lines[nextIdx]?.length >= 5) return lines[nextIdx];
                    }
                    return null;
                }
                
                // Helper function to interpolate between two line datasets
                function interpolateLines(data0, data1, t, scaleFactor = 1.0, isLegacy = false) {
                    const positions = [];
                    const len = Math.min(data0.length, data1.length);
                    
                    for (let i = 0; i < len; i++) {
                        const p0 = data0[i];
                        const p1 = data1[i];
                        if (isLegacy) {
                            // Legacy format needs scaling for x and z
                            const x = p0[0] * scaleFactor * (1 - t) + p1[0] * scaleFactor * t;
                            const y = p0[1] * (1 - t) + p1[1] * t;
                            const z = p0[2] * scaleFactor * (1 - t) + p1[2] * scaleFactor * t;
                            positions.push(x, y, z);
                        } else {
                            // New format: direct coordinates
                            const x = p0[0] * (1 - t) + p1[0] * t;
                            const y = p0[1] * (1 - t) + p1[1] * t;
                            const z = p0[2] * (1 - t) + p1[2] * t;
                            positions.push(x, y, z);
                        }
                    }
                    return positions;
                }
                
                if (ftData.isLegacy) {
                    // Legacy format: rawLines array with scaling
                    lineData0 = findValidLineData(lonIndex0, null);
                    lineData1 = findValidLineData(lonIndex1, null);
                    
                    if (lineData0 && lineData0.length >= 5 && lineData1 && lineData1.length >= 5) {
                        // Interpolate between the two longitude samples
                        const positions = interpolateLines(lineData0, lineData1, interpFactor, ftData.scaleFactor, true);
                        
                        // Add surface extensions at start and end
                        const firstPt = [positions[0], positions[1], positions[2]];
                        const lastPt = [positions[positions.length - 3], positions[positions.length - 2], positions[positions.length - 1]];
                        const startExt = extendToSurface(firstPt, oblateness);
                        const endExt = extendToSurface(lastPt, oblateness);
                        
                        // Prepend start extension, append end extension
                        const finalPositions = [startExt[0], startExt[1], startExt[2], ...positions, endExt[0], endExt[1], endExt[2]];
                        
                        // Update geometry
                        const expectedLength = finalPositions.length;
                        const currentLength = ftData.lastPositions ? ftData.lastPositions.length : 0;
                        
                        if (currentLength !== expectedLength) {
                            if (fluxTube.geometry) fluxTube.geometry.dispose();
                            const newGeometry = new LineGeometry();
                            newGeometry.setPositions(finalPositions);
                            fluxTube.geometry = newGeometry;
                        } else {
                            fluxTube.geometry.setPositions(finalPositions);
                        }
                        
                        fluxTube.computeLineDistances();
                        fluxTube.visible = true;
                        ftData.lastPositions = finalPositions;
                    } else if (lineData0 && lineData0.length >= 5) {
                        // Fallback to single sample if interpolation not possible
                        const positions = [];
                        const startExt = extendToSurface([lineData0[0][0] * ftData.scaleFactor, lineData0[0][1], lineData0[0][2] * ftData.scaleFactor], oblateness);
                        positions.push(startExt[0], startExt[1], startExt[2]);
                        for (const p of lineData0) {
                            positions.push(p[0] * ftData.scaleFactor, p[1], p[2] * ftData.scaleFactor);
                        }
                        const endExt = extendToSurface([lineData0[lineData0.length - 1][0] * ftData.scaleFactor, lineData0[lineData0.length - 1][1], lineData0[lineData0.length - 1][2] * ftData.scaleFactor], oblateness);
                        positions.push(endExt[0], endExt[1], endExt[2]);
                        
                        const expectedLength = positions.length;
                        const currentLength = ftData.lastPositions ? ftData.lastPositions.length : 0;
                        if (currentLength !== expectedLength) {
                            if (fluxTube.geometry) fluxTube.geometry.dispose();
                            const newGeometry = new LineGeometry();
                            newGeometry.setPositions(positions);
                            fluxTube.geometry = newGeometry;
                        } else {
                            fluxTube.geometry.setPositions(positions);
                        }
                        fluxTube.computeLineDistances();
                        fluxTube.visible = true;
                        ftData.lastPositions = positions;
                    } else {
                        console.error(`[updateFluxTubes] Moon ${moonIndex}: No valid data found!`);
                    }
                } else {
                    // New format: use pre-calculated moon flux tubes with interpolation
                    const radialSample = ftData.radialSamples[ftData.currentRadialIndex];
                    lineData0 = findValidLineData(lonIndex0, radialSample);
                    lineData1 = findValidLineData(lonIndex1, radialSample);
                    
                    if (lineData0 && lineData0.length >= 5 && lineData1 && lineData1.length >= 5) {
                        // Interpolate between the two longitude samples for smooth animation
                        const positions = interpolateLines(lineData0, lineData1, interpFactor, 1.0, false);
                        
                        // Update geometry
                        const expectedLength = positions.length;
                        const currentLength = ftData.lastPositions ? ftData.lastPositions.length : 0;
                        
                        if (currentLength !== expectedLength) {
                            if (fluxTube.geometry) fluxTube.geometry.dispose();
                            const newGeometry = new LineGeometry();
                            newGeometry.setPositions(positions);
                            fluxTube.geometry = newGeometry;
                        } else {
                            fluxTube.geometry.setPositions(positions);
                        }
                        
                        fluxTube.computeLineDistances();
                        fluxTube.visible = true;
                        ftData.lastPositions = positions;
                        
                        if (DEBUG_FLUX_TUBES) console.log(`[updateFluxTubes] Moon ${moonIndex}: Interpolated between ${lonIndex0} and ${lonIndex1} (t=${interpFactor.toFixed(3)}) ✓`);
                    } else if (lineData0 && lineData0.length >= 5) {
                        // Fallback to single sample if second sample not available
                        const positions = [];
                        for (const p of lineData0) {
                            positions.push(p[0], p[1], p[2]);
                        }
                        
                        const expectedLength = positions.length;
                        const currentLength = ftData.lastPositions ? ftData.lastPositions.length : 0;
                        if (currentLength !== expectedLength) {
                            if (fluxTube.geometry) fluxTube.geometry.dispose();
                            const newGeometry = new LineGeometry();
                            newGeometry.setPositions(positions);
                            fluxTube.geometry = newGeometry;
                        } else {
                            fluxTube.geometry.setPositions(positions);
                        }
                        fluxTube.computeLineDistances();
                        fluxTube.visible = true;
                        ftData.lastPositions = positions;
                    } else {
                        console.error(`[updateFluxTubes] Moon ${moonIndex}: No valid data found!`);
                        if (ftData.lastPositions) {
                            fluxTube.visible = true;
                        } else {
                            fluxTube.visible = false;
                        }
                    }
                }
            });
        }
        
        // Aurora L-shells for each planet
        const AURORA_L_SHELLS = {
            earth: 6.0,
            jupiter: 50.0,
            saturn: 20.0
        };
        
        // Create aurora particles from field line footprints
        function createAurora(data) {
            // Only create aurora for Earth, Jupiter, Saturn
            if (!['earth', 'jupiter', 'saturn'].includes(currentPlanet)) return;
            
            const auroraL = AURORA_L_SHELLS[currentPlanet];
            const oblateness = data.oblateness || 1.0;
            
            // Find the L-shell closest to our aurora L
            let closestLData = null;
            let closestDist = Infinity;
            for (const lData of data.l_shells) {
                const dist = Math.abs(lData.L - auroraL);
                if (dist < closestDist) {
                    closestDist = dist;
                    closestLData = lData;
                }
            }
            
            if (!closestLData || !closestLData.lines) return;
            
            console.log(`Creating aurora at L=${closestLData.L} with ${closestLData.lines.length} field lines`);
            
            // Collect footprints from all field lines
            const particles = [];
            const colors = [];
            
            // Create longitude clumps for variable coverage
            const numClumps = 8 + Math.floor(Math.random() * 6);  // 8-13 clumps
            const clumpCenters = [];
            const clumpWidths = [];
            for (let c = 0; c < numClumps; c++) {
                clumpCenters.push(Math.random() * Math.PI * 2);
                clumpWidths.push(0.2 + Math.random() * 0.4);  // Variable width per clump
            }
            
            // Use ALL available field lines for full 360° coverage
            // For each field line, also create interpolated aurora between them
            const totalLines = closestLData.lines.length;
            // Resolution: 720 samples (0.5° steps) for moon flux tubes - no interpolation needed
            const targetLongitudes = 720;  // Target 720 samples for smooth aurora
            const interpolationFactor = Math.ceil(targetLongitudes / totalLines);
            
            for (let lonIdx = 0; lonIdx < totalLines * interpolationFactor; lonIdx++) {
                // Get the base field line and optionally interpolate
                const baseLineIdx = Math.floor(lonIdx / interpolationFactor) % totalLines;
                const nextLineIdx = (baseLineIdx + 1) % totalLines;
                const interpT = (lonIdx % interpolationFactor) / interpolationFactor;
                
                const linePoints = closestLData.lines[baseLineIdx];
                const nextLinePoints = closestLData.lines[nextLineIdx];
                if (!linePoints || linePoints.length < 5) continue;
                
                // Calculate longitude angle for clumping
                const firstPoint = linePoints[0];
                const baseLonAngle = Math.atan2(firstPoint[2], firstPoint[0]);
                const lonAngle = baseLonAngle + (interpT * Math.PI * 2 / totalLines);
                
                // Check if this longitude is in a clump (higher density) or gap (lower density)
                let inClump = false;
                let clumpIntensity = 0.3;  // Base intensity for gaps
                for (let c = 0; c < numClumps; c++) {
                    const dist = Math.abs(lonAngle - clumpCenters[c]);
                    const wrappedDist = Math.min(dist, Math.PI * 2 - dist);
                    if (wrappedDist < clumpWidths[c]) {
                        inClump = true;
                        clumpIntensity = Math.max(clumpIntensity, 1.0 - (wrappedDist / clumpWidths[c]) * 0.5);
                    }
                }
                
                // Get footprints at both ends of the field line
                // Interpolate between this line and next for more coverage
                const footprints = [];
                
                // Northern footprint (first point)
                const fp1 = linePoints[0];
                if (nextLinePoints && nextLinePoints.length > 0 && interpT > 0) {
                    const fp2 = nextLinePoints[0];
                    footprints.push([
                        fp1[0] * (1-interpT) + fp2[0] * interpT,
                        fp1[1] * (1-interpT) + fp2[1] * interpT,
                        fp1[2] * (1-interpT) + fp2[2] * interpT
                    ]);
                } else {
                    footprints.push(fp1);
                }
                
                // Southern footprint (last point)
                const sp1 = linePoints[linePoints.length - 1];
                if (nextLinePoints && nextLinePoints.length > 0 && interpT > 0) {
                    const sp2 = nextLinePoints[nextLinePoints.length - 1];
                    footprints.push([
                        sp1[0] * (1-interpT) + sp2[0] * interpT,
                        sp1[1] * (1-interpT) + sp2[1] * interpT,
                        sp1[2] * (1-interpT) + sp2[2] * interpT
                    ]);
                } else {
                    footprints.push(sp1);
                }
                
                footprints.forEach(fp => {
                    // Vary particle count based on clump intensity
                    const baseParticles = inClump ? 15 : 5;
                    const numParticles = Math.floor(baseParticles * clumpIntensity);
                    
                    for (let i = 0; i < numParticles; i++) {
                        // The footprint is already at r~1.0 (surface)
                        // For oblate planets, we need to account for oblateness
                        const basePos = new THREE.Vector3(fp[0], fp[1], fp[2]);
                        const r = basePos.length();
                        
                        // Normalize to get direction, then place at oblate surface
                        const dir = basePos.clone().normalize();
                        
                        // For oblate surface: x,z are equatorial, y is polar
                        // Surface is at: x²/1² + z²/1² + y²/oblateness² = 1
                        // Simplify: we scale y by oblateness to get unit sphere, find surface, scale back
                        const surfaceR = 1.0 / Math.sqrt(
                            dir.x * dir.x + dir.z * dir.z + (dir.y * dir.y) / (oblateness * oblateness)
                        );
                        
                        // Height distribution - planet-specific heights (reduced by 50%)
                        // Saturn: 0.015 planet radii, Earth/Jupiter: 0.025 planet radii
                        const maxHeight = currentPlanet === 'saturn' ? 0.015 : 0.025;
                        const heightFactor = Math.pow(Math.random(), 2.5);  // Concentrated at base
                        const height = heightFactor * maxHeight;
                        
                        // Position at oblate surface + height along radial direction
                        const pos = dir.clone().multiplyScalar(surfaceR + height);
                        
                        // Add tangential spread for fuzziness
                        const spread = 0.012;
                        pos.x += (Math.random() - 0.5) * spread;
                        pos.y += (Math.random() - 0.5) * spread;
                        pos.z += (Math.random() - 0.5) * spread;
                        
                        particles.push(pos.x, pos.y, pos.z);
                        
                        // Color variation
                        let r_col, g, b;
                        if (currentPlanet === 'saturn') {
                            // Red-orange aurora for Saturn
                            const colorType = Math.random();
                            if (colorType < 0.6) {
                                r_col = 1.0; g = 0.3 + Math.random() * 0.3; b = 0.1 + Math.random() * 0.2;
                            } else {
                                r_col = 1.0; g = 0.5 + Math.random() * 0.3; b = 0.2 + Math.random() * 0.2;
                            }
                        } else if (currentPlanet === 'jupiter') {
                            // Red-orange aurora for Jupiter
                            const colorType = Math.random();
                            if (colorType < 0.6) {
                                r_col = 1.0; g = 0.3 + Math.random() * 0.2; b = 0.1;
                            } else {
                                r_col = 1.0; g = 0.5 + Math.random() * 0.3; b = 0.2 + Math.random() * 0.2;
                            }
                        } else {
                            // Green-purple aurora for Earth
                            const colorType = Math.random();
                            if (colorType < 0.6) {
                                r_col = 0.1 + Math.random() * 0.2; g = 0.8 + Math.random() * 0.2; b = 0.3 + Math.random() * 0.3;
                            } else if (colorType < 0.85) {
                                r_col = 0.3 + Math.random() * 0.2; g = 0.4 + Math.random() * 0.2; b = 0.8 + Math.random() * 0.2;
                            } else {
                                r_col = 0.5 + Math.random() * 0.3; g = 0.6 + Math.random() * 0.2; b = 0.9;
                            }
                        }
                        colors.push(r_col, g, b);
                    }
                });
            }
            
            if (particles.length === 0) return;
            
            // Create particle system
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(particles, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.025,
                vertexColors: true,
                transparent: true,
                opacity: 0.4,  // Half opacity (was 0.8)
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            auroraParticles = new THREE.Points(geometry, material);
            auroraParticles.visible = showAurora;
            tiltGroup.add(auroraParticles);
            
            console.log(`Created aurora with ${particles.length / 3} particles`);
        }
        
        // Update aurora visibility
        function updateAurora() {
            if (auroraParticles) {
                auroraParticles.visible = showAurora;
            }
        }
        
        // Apply or remove axial tilt
        function applyAxialTilt() {
            if (!tiltGroup || !planetData) return;
            
            const axialTilt = planetData.axial_tilt || 0;
            const flipNorth = planetData.flip_north || false;
            
            if (showAxialTilt && axialTilt !== 0) {
                // Convert to radians and apply tilt around X axis
                let tiltRad = THREE.MathUtils.degToRad(axialTilt);
                tiltGroup.rotation.x = tiltRad;
                
                // For Uranus (flip_north=true), when tilted, flip the north arrow
                // because IAU north is actually on the "bottom" side after tilting
                if (northPoleArrow && flipNorth) {
                    northPoleArrow.rotation.z = Math.PI;  // Flip 180° so N points to true north
                }
            } else {
                tiltGroup.rotation.x = 0;
                // Reset north pole arrow when tilt is off
                if (northPoleArrow) {
                    northPoleArrow.rotation.z = 0;
                }
            }
        }

        async function loadPlanet(planetKey) {
            const loader = document.getElementById('loading');
            const loadingText = document.getElementById('loading-text');
            
            loader.style.display = 'block';
            document.getElementById('controls').style.display = 'none';
            loadingText.textContent = `Loading ${PLANET_CONFIGS[planetKey].name}...`;
            
            clearScene();
            currentPlanet = planetKey;
            
            try {
                const response = await fetch(`field_lines_${planetKey}.json`);
                planetData = await response.json();
                
                // Create a tilt group to hold all objects that get tilted together
                tiltGroup = new THREE.Group();
                scene.add(tiltGroup);
                
                createPlanet(planetData);
                createEquator(planetData);
                createNorthPoleArrow(planetData);
                createPlanetaryGrid(planetData);
                createRings();
                createMoons(planetData);
                createFieldLines(planetData);
                createFluxTubes(planetData);
                createAurora(planetData);
                
                // Create plasma torus for Saturn (Enceladus) or Jupiter (Io)
                if (planetKey === 'saturn') {
                    createEnceladusERing();
                } else if (planetKey === 'jupiter') {
                    createIoTorus(planetData);
                }
                
                // Update UI
                document.getElementById('planet-title').textContent = `${planetData.planet} Magnetic Field`;
                document.getElementById('model-info').textContent = PLANET_CONFIGS[planetKey].modelInfo;
                
                // Show/hide controls based on planet
                document.getElementById('rings-group').style.display = planetKey === 'saturn' ? 'flex' : 'none';
                
                // Show torus toggle for Saturn and Jupiter
                const hasTorus = ['saturn', 'jupiter'].includes(planetKey);
                document.getElementById('torus-group').style.display = hasTorus ? 'flex' : 'none';
                document.getElementById('show-torus').checked = showTorus;
                if (hasTorus) {
                    const torusName = planetKey === 'saturn' ? 'E-ring' : 'Io Torus';
                    document.getElementById('torus-label').textContent = `Show ${torusName}`;
                }
                
                // Show flux tube toggle for planets with moons
                const hasFluxTubes = ['jupiter', 'saturn', 'uranus', 'neptune'].includes(planetKey);
                document.getElementById('flux-tube-group').style.display = hasFluxTubes ? 'flex' : 'none';
                document.getElementById('show-flux-tubes').checked = showFluxTube;
                
                // Update axial tilt label with planet's tilt value (IAU convention)
                const axialTilt = planetData.axial_tilt || 0;
                document.getElementById('tilt-label').textContent = `Show Axial Tilt (IAU; ${axialTilt.toFixed(1)}°)`;
                
                // Reset tilt checkbox state and apply tilt if checked
                document.getElementById('show-tilt').checked = showAxialTilt;
                applyAxialTilt();
                
                // Update dropdown to show current planet
                document.getElementById('planet-dropdown').value = planetKey;
                
                loader.style.display = 'none';
                document.getElementById('controls').style.display = 'block';
                
            } catch (error) {
                console.error('Failed to load planet data:', error);
                loadingText.textContent = 'Error: ' + error.message;
            }
        }
        
        // Event listeners
        document.getElementById('planet-dropdown').addEventListener('change', (e) => {
            loadPlanet(e.target.value);
        });
        
        // Toggle controls visibility
        document.getElementById('toggle-controls').addEventListener('click', () => {
            const controls = document.getElementById('controls');
            const btn = document.getElementById('toggle-controls');
            if (controls.style.display === 'none' || controls.style.display === '') {
                controls.style.display = 'block';
                btn.textContent = 'Hide Controls';
            } else {
                controls.style.display = 'none';
                btn.textContent = 'Show Controls';
            }
        });
        
        document.getElementById('l-slider').addEventListener('input', (e) => {
            const idx = parseInt(e.target.value);
            const L = L_SHELLS_LOADED[idx] || 1.1;
            document.getElementById('l-value').textContent = L.toFixed(1);
            updateVisibleFieldLines(L);
        });
        
        document.getElementById('longitude-slider').addEventListener('input', (e) => {
            document.getElementById('longitude-value').textContent = e.target.value;
            updateLongitudes(parseInt(e.target.value));
        });
        
        document.getElementById('thickness-slider').addEventListener('input', (e) => {
            const thickness = parseFloat(e.target.value);
            document.getElementById('thickness-value').textContent = thickness.toFixed(1);
            updateThickness(thickness);
        });
        
        document.getElementById('show-rings').addEventListener('change', (e) => {
            if (ringsMesh) ringsMesh.visible = e.target.checked;
        });
        

        
        document.getElementById('auto-rotate').addEventListener('change', (e) => {
            autoRotate = e.target.checked;
            document.getElementById('speed-group').style.display = autoRotate ? 'block' : 'none';
        });
        
        document.getElementById('show-tilt').addEventListener('change', (e) => {
            showAxialTilt = e.target.checked;
            applyAxialTilt();
        });
        
        document.getElementById('show-torus').addEventListener('change', (e) => {
            showTorus = e.target.checked;
            if (plasmaTorus) {
                plasmaTorus.visible = showTorus;
            }
        });
        
        document.getElementById('show-flux-tubes').addEventListener('change', (e) => {
            showFluxTube = e.target.checked;
            fluxTubeLines.forEach(ft => {
                if (ft) ft.visible = showFluxTube;
            });
        });
        
        document.getElementById('speed-slider').addEventListener('input', (e) => {
            rotationSpeedMultiplier = parseFloat(e.target.value);
            document.getElementById('speed-value').textContent = rotationSpeedMultiplier.toFixed(1) + 'x';
        });
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            
            fieldLineGroups.forEach((group) => {
                group.children.forEach(child => {
                    if (child.material && child.material.resolution) {
                        child.material.resolution.set(window.innerWidth, window.innerHeight);
                    }
                });
            });
            
            fluxTubeLines.forEach(line => {
                if (line && line.material && line.material.resolution) {
                    line.material.resolution.set(window.innerWidth, window.innerHeight);
                }
            });
            
            moonOrbitLines.forEach(orbitLine => {
                if (orbitLine && orbitLine.material && orbitLine.material.resolution) {
                    orbitLine.material.resolution.set(window.innerWidth, window.innerHeight);
                }
            });
        });
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (autoRotate && planetData) {
                const rotationPeriod = planetData.rotation_period_hours;
                const planetSpeed = 0.003 * rotationSpeedMultiplier;
                planetRotation += planetSpeed;
                
                if (planetMesh) planetMesh.rotation.y = planetRotation;
                if (ringsMesh) ringsMesh.rotation.y = planetRotation;
                if (equatorLine) equatorLine.rotation.y = planetRotation;
                if (northPoleArrow) northPoleArrow.rotation.y = planetRotation;
                if (planetGrid) planetGrid.rotation.y = planetRotation;
                if (auroraParticles) auroraParticles.rotation.y = planetRotation;
                if (plasmaTorus) plasmaTorus.rotation.y = planetRotation;
                
                fieldLineGroups.forEach(group => {
                    group.rotation.y = planetRotation;
                });
                
                // DON'T rotate flux tube lines - they're updated via geometry changes to track moons
                // fluxTubeLines are in tiltGroup and their geometry is set to match moon position
                
                // Animate moons at their correct orbital speeds
                // Planet rotates at planetSpeed rad/frame
                // Moon orbital angular velocity = 2π / (period_hours * frames_per_hour)
                // But we want relative to planet: if planet period = 10h and moon = 40h,
                // then in 10h planet rotates 360° and moon rotates 90°
                // So moon angular velocity = planet angular velocity * (planet_period / moon_period)
                moonMeshes.forEach((moon, index) => {
                    const moonData = moon.userData;
                    // Moon orbital angular velocity relative to inertial frame
                    // If planet rotates 360° in rotationPeriod hours, 
                    // moon orbits 360° in moonData.period_hours
                    const orbitRatio = rotationPeriod / moonData.period_hours;
                    moonOrbitAngles[index] += planetSpeed * orbitRatio;
                    
                    // Update moon position IN THE EQUATORIAL PLANE (y=0 in tiltGroup frame)
                    moon.position.x = moonData.orbit_radius * Math.cos(moonOrbitAngles[index]);
                    moon.position.y = 0;  // CRITICAL: Moon orbits in equatorial plane!
                    moon.position.z = moonData.orbit_radius * -Math.sin(moonOrbitAngles[index]);
                });
                
                // Update flux tubes to follow moons
                updateFluxTubes();
            }
            
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }
        
        // Start
        loadPlanet('earth');
        animate();
    </script>
</body>
</html>
