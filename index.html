<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planetary Magnetic Field Explorer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        #canvas-container { width: 100vw; height: 100vh; }
        #controls {
            position: fixed;
            top: 50px;
            right: 15px;
            background: rgba(20, 20, 30, 0.9);
            padding: 12px;
            border-radius: 9px;
            min-width: 260px;
            box-shadow: 0 3px 15px rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            z-index: 100;
            font-size: 0.75em;
        }
        h1 {
            font-size: 1.1em;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #planet-title { color: #f0d890; }
        .control-group { margin-bottom: 10px; }
        label { display: block; margin-bottom: 5px; font-size: 0.85em; color: #aaa; }
        .slider-container { display: flex; align-items: center; gap: 8px; }
        input[type="range"] {
            flex: 1;
            appearance: none;
            height: 5px;
            background: #333;
            border-radius: 2px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #f0d890;
            border-radius: 50%;
            cursor: pointer;
        }
        .value-display { min-width: 36px; text-align: right; font-weight: bold; color: #f0d890; }
        .checkbox-group { display: flex; align-items: center; gap: 8px; margin-top: 6px; }
        .checkbox-group input[type="checkbox"] { width: 14px; height: 14px; cursor: pointer; }
        .checkbox-group label { margin: 0; cursor: pointer; color: #ddd; }
        
        .planet-selector {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 12px;
        }
        .planet-btn {
            padding: 6px 12px;
            border: 1px solid #444;
            background: #222;
            color: #aaa;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
        }
        .planet-btn:hover { background: #333; border-color: #666; }
        .planet-btn.active { background: #445; border-color: #88a; color: #fff; }
        .planet-btn.mercury { border-left: 3px solid #888; }
        .planet-btn.earth { border-left: 3px solid #4af; }
        .planet-btn.jupiter { border-left: 3px solid #fa4; }
        .planet-btn.saturn { border-left: 3px solid #a8f; }
        .planet-btn.uranus { border-left: 3px solid #4fa; }
        .planet-btn.neptune { border-left: 3px solid #48f; }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2em;
            color: #f0d890;
            z-index: 200;
            text-align: center;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #333;
            border-top-color: #f0d890;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #info { position: fixed; bottom: 15px; left: 15px; font-size: 0.7em; color: #666; max-width: 300px; }
        #model-info { color: #888; font-size: 0.75em; margin-top: 8px; padding-top: 8px; border-top: 1px solid #333; }
        #scale-note { 
            position: fixed; 
            bottom: 15px; 
            left: 50%; 
            transform: translateX(-50%); 
            font-size: 0.65em; 
            color: #555; 
            font-style: italic; 
            display: none;
        }
        #planet-selector {
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 100;
        }
        #planet-dropdown {
            padding: 8px 12px;
            font-size: 1em;
            background: rgba(20, 20, 30, 0.9);
            color: #f0d890;
            border: 1px solid #444;
            border-radius: 6px;
            cursor: pointer;
            min-width: 140px;
            backdrop-filter: blur(10px);
        }
        #planet-dropdown:hover { border-color: #666; }
        #planet-dropdown option { background: #222; color: #fff; }
        #toggle-controls {
            position: fixed;
            top: 15px;
            right: 15px;
            padding: 6px 12px;
            background: rgba(20, 20, 30, 0.9);
            color: #aaa;
            border: 1px solid #444;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8em;
            z-index: 101;
            backdrop-filter: blur(10px);
        }
        #toggle-controls:hover { background: #333; border-color: #666; color: #fff; }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text">Loading Earth...</div>
    </div>
    
    <div id="planet-selector">
        <select id="planet-dropdown">
            <option value="earth">Earth</option>
            <option value="jupiter">Jupiter</option>
            <option value="saturn">Saturn</option>
            <option value="uranus">Uranus</option>
            <option value="neptune">Neptune</option>
        </select>
    </div>
    
    <button id="toggle-controls">Hide Controls</button>
    
    <div id="controls" style="display: none;">
        <h1><span id="planet-title">Earth Magnetic Field</span></h1>
        
        <div class="control-group">
            <label>L-Shell Value</label>
            <div class="slider-container">
                <input type="range" id="l-slider" min="0" max="27" value="10" step="1">
                <span class="value-display" id="l-value">6.0</span>
            </div>
        </div>
        
        <div class="control-group">
            <label>Longitudes</label>
            <div class="slider-container">
                <input type="range" id="longitude-slider" min="1" max="24" value="8" step="1">
                <span class="value-display" id="longitude-value">8</span>
            </div>
        </div>
        
        <div class="control-group">
            <label>Line Thickness</label>
            <div class="slider-container">
                <input type="range" id="thickness-slider" min="1" max="8" value="2" step="0.5">
                <span class="value-display" id="thickness-value">2</span>
            </div>
        </div>
        
        <div class="control-group">
            <div class="checkbox-group" id="rings-group" style="display: none;">
                <input type="checkbox" id="show-rings" checked>
                <label for="show-rings">Show Rings</label>
            </div>
            <div class="checkbox-group" id="moon-group" style="display: none;">
                <input type="checkbox" id="show-moon" checked>
                <label for="show-moon" id="moon-label">Show Moon</label>
            </div>
            <div class="checkbox-group" id="flux-tube-group" style="display: none;">
                <input type="checkbox" id="show-flux-tube">
                <label for="show-flux-tube" id="flux-tube-label">Show Flux Tubes</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="auto-rotate">
                <label for="auto-rotate">Auto Rotate</label>
            </div>
            <div class="checkbox-group" id="aurora-group" style="display: none;">
                <input type="checkbox" id="show-aurora">
                <label for="show-aurora">Show Aurora</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="show-tilt">
                <label for="show-tilt" id="tilt-label">Show Axial Tilt (23.4°)</label>
            </div>
        </div>
        
        <div class="control-group" id="speed-group" style="display: none;">
            <label>Rotation Speed</label>
            <div class="slider-container">
                <input type="range" id="speed-slider" min="0.1" max="10" value="1" step="0.1">
                <span class="value-display" id="speed-value">1.0x</span>
            </div>
        </div>
        
        <div id="model-info"></div>
    </div>
    
    <div id="canvas-container"></div>
    <div id="info">Drag to rotate | Scroll to zoom</div>
    <div id="scale-note">moons not to scale</div>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000008);
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(25, 15, 25);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.getElementById('canvas-container').appendChild(labelRenderer.domElement);
        
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 2;
        controls.maxDistance = 200;
        controls.zoomSpeed = 2.0;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        sunLight.position.set(15, 8, 15);
        scene.add(sunLight);
        const fillLight = new THREE.DirectionalLight(0xffffcc, 0.5);
        fillLight.position.set(-10, -5, -10);
        scene.add(fillLight);
        
        // Flux tube colors for different moons
        const FLUX_TUBE_COLORS = [0x33ff88, 0xff8833, 0x8833ff, 0x33ffff];
        
        const PLANET_CONFIGS = {
            earth: {
                name: 'Earth',
                fieldColor: 0x44aaff,
                defaultL: 6,
                modelInfo: 'IGRF 2020 model',
                useTexture: 'Earth_Diffuse_1K.jpg'
            },
            jupiter: {
                name: 'Jupiter',
                fieldColor: 0xffaa44,
                defaultL: 10,
                modelInfo: 'JRM33 + Con2020 model'
            },
            saturn: {
                name: 'Saturn',
                fieldColor: 0xaa88ff,
                defaultL: 20,
                modelInfo: 'Cassini 11 model'
            },
            uranus: {
                name: 'Uranus',
                fieldColor: 0x44ffaa,
                defaultL: 10,
                modelInfo: 'GSFC Q3 model'
            },
            neptune: {
                name: 'Neptune',
                fieldColor: 0x4488ff,
                defaultL: 10,
                modelInfo: 'GSFC O8 model'
            }
        };
        
        // State
        let currentPlanet = 'earth';
        let planetData = null;
        let planetMesh = null;
        let ringsMesh = null;
        let moonMeshes = [];
        let moonLabels = [];
        let fluxTubeLines = [];  // Array: one group per moon
        let moonOrbitLines = [];  // Array: orbit circles for each moon
        let auroraParticles = null;  // Aurora particle system
        let fieldLineGroups = new Map();
        let equatorLine = null;
        let northPoleArrow = null;
        let autoRotate = false;
        let rotationSpeedMultiplier = 1.0;
        let showFluxTube = false;
        let showAxialTilt = false;
        let showAurora = false;
        let currentLongitudes = 8;
        let currentThickness = 2;
        let planetRotation = 0;
        let moonOrbitAngles = [];
        let L_SHELLS_LOADED = [];
        let tiltGroup = null;  // Group to hold all tilted objects
        
        const textureLoader = new THREE.TextureLoader();
        
        // Planet texture creation
        function createPlanetTexture(planetKey) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            const textures = {
                earth: () => {
                    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    gradient.addColorStop(0, '#aaddff');
                    gradient.addColorStop(0.15, '#4488cc');
                    gradient.addColorStop(0.5, '#2266aa');
                    gradient.addColorStop(0.85, '#4488cc');
                    gradient.addColorStop(1, '#aaddff');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                },
                jupiter: () => {
                    const bands = [
                        { pos: 0.0, color: '#c4a574' }, { pos: 0.1, color: '#d4b584' },
                        { pos: 0.2, color: '#e8c898' }, { pos: 0.3, color: '#c4a574' },
                        { pos: 0.4, color: '#aa8866' }, { pos: 0.5, color: '#e8c898' },
                        { pos: 0.6, color: '#aa8866' }, { pos: 0.7, color: '#c4a574' },
                        { pos: 0.8, color: '#e8c898' }, { pos: 1.0, color: '#c4a574' }
                    ];
                    for (let y = 0; y < canvas.height; y++) {
                        const t = y / canvas.height;
                        for (let i = 0; i < bands.length - 1; i++) {
                            if (t >= bands[i].pos && t <= bands[i + 1].pos) {
                                ctx.fillStyle = bands[i].color;
                                break;
                            }
                        }
                        ctx.fillRect(0, y, canvas.width, 1);
                    }
                    ctx.fillStyle = 'rgba(180, 80, 60, 0.6)';
                    ctx.beginPath();
                    ctx.ellipse(300, 280, 40, 25, 0, 0, Math.PI * 2);
                    ctx.fill();
                },
                saturn: () => {
                    const bands = [
                        { pos: 0.0, color: '#c4a574' }, { pos: 0.25, color: '#e0c998' },
                        { pos: 0.45, color: '#e8d4a8' }, { pos: 0.5, color: '#f0ddb0' },
                        { pos: 0.55, color: '#e8d4a8' }, { pos: 0.75, color: '#e0c998' },
                        { pos: 1.0, color: '#c4a574' }
                    ];
                    for (let y = 0; y < canvas.height; y++) {
                        const t = y / canvas.height;
                        for (let i = 0; i < bands.length - 1; i++) {
                            if (t >= bands[i].pos && t <= bands[i + 1].pos) {
                                ctx.fillStyle = bands[i].color;
                                break;
                            }
                        }
                        ctx.fillRect(0, y, canvas.width, 1);
                    }
                },
                uranus: () => {
                    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    gradient.addColorStop(0, '#88cccc');
                    gradient.addColorStop(0.5, '#55bbbb');
                    gradient.addColorStop(1, '#88cccc');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                },
                neptune: () => {
                    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    gradient.addColorStop(0, '#4477cc');
                    gradient.addColorStop(0.5, '#2255aa');
                    gradient.addColorStop(1, '#4477cc');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            };
            
            textures[planetKey]();
            
            // Add noise
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                const noise = (Math.random() - 0.5) * 15;
                imageData.data[i] = Math.max(0, Math.min(255, imageData.data[i] + noise));
                imageData.data[i + 1] = Math.max(0, Math.min(255, imageData.data[i + 1] + noise));
                imageData.data[i + 2] = Math.max(0, Math.min(255, imageData.data[i + 2] + noise));
            }
            ctx.putImageData(imageData, 0, 0);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            return texture;
        }
        
        function clearScene() {
            // Remove tiltGroup if exists
            if (tiltGroup) {
                scene.remove(tiltGroup);
                tiltGroup = null;
            }
            
            if (planetMesh) {
                scene.remove(planetMesh);
                planetMesh.geometry.dispose();
                planetMesh.material.dispose();
                planetMesh = null;
            }
            
            if (ringsMesh) {
                scene.remove(ringsMesh);
                ringsMesh.children.forEach(child => {
                    child.geometry.dispose();
                    child.material.dispose();
                });
                ringsMesh = null;
            }
            
            if (equatorLine) {
                scene.remove(equatorLine);
                if (equatorLine.geometry) equatorLine.geometry.dispose();
                if (equatorLine.material) equatorLine.material.dispose();
                equatorLine = null;
            }
            
            if (northPoleArrow) {
                // Remove CSS2D label elements
                northPoleArrow.children.forEach(child => {
                    if (child.element) {
                        child.element.remove();
                    }
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                scene.remove(northPoleArrow);
                northPoleArrow = null;
            }
            
            moonMeshes.forEach(moon => {
                // Remove labels attached to moon
                moon.children.forEach(child => {
                    if (child.element) {
                        child.element.remove();
                    }
                });
                scene.remove(moon);
                moon.geometry.dispose();
                moon.material.dispose();
            });
            moonMeshes = [];
            moonLabels = [];
            moonOrbitAngles = [];
            
            // Clear moon orbit lines
            moonOrbitLines.forEach(orbitLine => {
                if (orbitLine) {
                    if (orbitLine.geometry) orbitLine.geometry.dispose();
                    if (orbitLine.material) orbitLine.material.dispose();
                    scene.remove(orbitLine);
                }
            });
            moonOrbitLines = [];
            
            // Clear aurora particles
            if (auroraParticles) {
                if (auroraParticles.geometry) auroraParticles.geometry.dispose();
                if (auroraParticles.material) auroraParticles.material.dispose();
                scene.remove(auroraParticles);
                auroraParticles = null;
            }
            
            // Clear all flux tube lines
            fluxTubeLines.forEach(ft => {
                if (ft) {
                    if (ft.geometry) ft.geometry.dispose();
                    if (ft.material) ft.material.dispose();
                    tiltGroup.remove(ft);
                }
            });
            fluxTubeLines = [];
            fluxTubeData = [];
            
            fieldLineGroups.forEach(group => {
                group.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                scene.remove(group);
            });
            fieldLineGroups.clear();
        }
        
        function createPlanet(data) {
            const oblateness = data.oblateness || 1.0;
            const geometry = new THREE.SphereGeometry(1, 64, 32);
            const positions = geometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                positions.setY(i, positions.getY(i) * oblateness);
            }
            geometry.computeVertexNormals();
            
            const config = PLANET_CONFIGS[currentPlanet];
            let material;
            
            if (config.useTexture) {
                // Load real texture for Earth
                const texture = textureLoader.load(config.useTexture);
                // Rotate texture 180° to align 0° longitude correctly
                texture.offset.x = 0.5;
                texture.wrapS = THREE.RepeatWrapping;
                material = new THREE.MeshStandardMaterial({
                    map: texture,
                    roughness: 0.8,
                    metalness: 0.1
                });
            } else {
                const texture = createPlanetTexture(currentPlanet);
                material = new THREE.MeshStandardMaterial({
                    map: texture,
                    roughness: 0.8,
                    metalness: 0.1
                });
            }
            
            planetMesh = new THREE.Mesh(geometry, material);
            tiltGroup.add(planetMesh);
        }
        
        function createEquator(data) {
            const oblateness = data.oblateness || 1.0;
            // Create equator circle at y=0
            const segments = 128;
            const points = [];
            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                points.push(new THREE.Vector3(
                    Math.cos(theta) * 1.002,  // Slightly outside planet surface
                    0,
                    Math.sin(theta) * 1.002
                ));
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: 0xffff00,
                transparent: true,
                opacity: 0.7
            });
            equatorLine = new THREE.Line(geometry, material);
            tiltGroup.add(equatorLine);
        }
        
        function createNorthPoleArrow(data) {
            const oblateness = data.oblateness || 1.0;
            // flip_north is only used when axial tilt is shown - when tilt is off, north is always up
            const arrowGroup = new THREE.Group();
            
            // Arrow shaft - from south pole through north pole (2x longer, thicker)
            // Total length = 2 * oblateness + 1.0 on each side = covers both poles plus extension
            const shaftLength = oblateness * 2 + 2.0;  // Through planet + 1.0 extension each side
            const shaftGeometry = new THREE.CylinderGeometry(0.04, 0.04, shaftLength, 8);
            const shaftMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
            shaft.position.y = 0;  // Centered at origin
            arrowGroup.add(shaft);
            
            // Arrow head cone - always points up (north) when tilt is off
            // When tilt is on and flip_north is true, the tiltGroup rotation handles it
            const coneGeometry = new THREE.ConeGeometry(0.12, 0.3, 8);
            const coneMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const cone = new THREE.Mesh(coneGeometry, coneMaterial);
            cone.position.y = shaftLength / 2 + 0.15;  // Top of shaft + half cone height
            arrowGroup.add(cone);
            
            // Add "N" label (white) - always at the top
            const labelDiv = document.createElement('div');
            labelDiv.textContent = 'N';
            labelDiv.style.cssText = 'color:#ffffff;font-size:14px;font-weight:bold;text-shadow:0 0 3px #000;';
            const label = new CSS2DObject(labelDiv);
            label.position.set(0, shaftLength / 2 + 0.5, 0);
            arrowGroup.add(label);
            
            northPoleArrow = arrowGroup;
            tiltGroup.add(northPoleArrow);
        }
        
        function createRings() {
            if (currentPlanet !== 'saturn') return;
            
            const ringsGroup = new THREE.Group();
            const RING_STRUCTURE = [
                { inner: 1.110, outer: 1.236, opacity: 0.15, brightness: 0.3 },
                { inner: 1.239, outer: 1.527, opacity: 0.50, brightness: 0.525 },
                { inner: 1.527, outer: 1.951, opacity: 0.85, brightness: 1.0 },
                { inner: 1.951, outer: 2.023, opacity: 0.05, brightness: 0.15 },
                { inner: 2.023, outer: 2.270, opacity: 0.65, brightness: 0.7 },
                { inner: 2.310, outer: 2.330, opacity: 0.4, brightness: 0.5 },
            ];
            
            RING_STRUCTURE.forEach(ring => {
                const geometry = new THREE.RingGeometry(ring.inner, ring.outer, 128, 1);
                geometry.rotateX(-Math.PI / 2);
                const brightness = Math.floor(ring.brightness * 200 + 55);
                const color = new THREE.Color(`rgb(${brightness}, ${brightness - 20}, ${brightness - 40})`);
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: ring.opacity
                });
                ringsGroup.add(new THREE.Mesh(geometry, material));
            });
            
            ringsMesh = ringsGroup;
            tiltGroup.add(ringsMesh);
        }
        
        function createMoons(data) {
            if (!data.moons || data.moons.length === 0) return;
            
            data.moons.forEach((moon, index) => {
                // Create moon orbit circle using thick lines
                const orbitSegments = 128;
                const orbitPositions = [];
                for (let i = 0; i <= orbitSegments; i++) {
                    const theta = (i / orbitSegments) * Math.PI * 2;
                    orbitPositions.push(
                        Math.cos(theta) * moon.orbit_radius,
                        0,
                        Math.sin(theta) * moon.orbit_radius
                    );
                }
                const orbitGeometry = new LineGeometry();
                orbitGeometry.setPositions(orbitPositions);
                const orbitMaterial = new LineMaterial({ 
                    color: 0x888888,
                    linewidth: 2,
                    transparent: true,
                    opacity: 0.7,
                    resolution: new THREE.Vector2(window.innerWidth, window.innerHeight)
                });
                const orbitLine = new Line2(orbitGeometry, orbitMaterial);
                orbitLine.computeLineDistances();
                tiltGroup.add(orbitLine);
                moonOrbitLines.push(orbitLine);
                
                // Make moons visually 2x thicker than flux tubes
                // Flux tube linewidth is 4 pixels, so moon should be clearly larger
                // Using 0.15 radius makes moons nicely visible compared to flux tube lines
                const moonSize = 0.15;
                const geometry = new THREE.SphereGeometry(moonSize, 16, 16);
                const material = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    roughness: 0.8,
                    emissive: 0x333333
                });
                const moonMesh = new THREE.Mesh(geometry, material);
                moonMesh.position.set(moon.orbit_radius, 0, 0);
                moonMesh.userData = moon;
                moonMesh.userData.displaySize = moonSize;
                tiltGroup.add(moonMesh);
                moonMeshes.push(moonMesh);
                
                const labelDiv = document.createElement('div');
                labelDiv.textContent = moon.name;
                labelDiv.style.cssText = 'color:#fff;font-size:11px;text-shadow:0 0 4px #000;font-weight:bold;';
                const label = new CSS2DObject(labelDiv);
                label.position.set(0, moonSize + 0.1, 0);
                moonMesh.add(label);
                moonLabels.push(label);
                
                moonOrbitAngles.push(0);
            });
        }
        
        function createFieldLines(data) {
            const oblateness = data.oblateness || 1.0;
            
            data.l_shells.forEach((lData) => {
                const L = lData.L;
                const group = new THREE.Group();
                group.visible = false;
                group.userData.L = L;
                group.userData.allLines = lData.lines;
                
                createLinesForGroup(group, currentLongitudes, oblateness);
                
                fieldLineGroups.set(L, group);
                tiltGroup.add(group);
            });
            
            L_SHELLS_LOADED = data.l_shells.map(ls => ls.L);
            
            const slider = document.getElementById('l-slider');
            slider.max = L_SHELLS_LOADED.length - 1;
            
            const config = PLANET_CONFIGS[currentPlanet];
            const defaultL = config.defaultL;
            let defaultIndex = 0;
            for (let i = 0; i < L_SHELLS_LOADED.length; i++) {
                if (L_SHELLS_LOADED[i] >= defaultL) {
                    defaultIndex = i;
                    break;
                }
            }
            slider.value = defaultIndex;
            updateVisibleFieldLines(L_SHELLS_LOADED[defaultIndex]);
            document.getElementById('l-value').textContent = L_SHELLS_LOADED[defaultIndex].toFixed(1);
        }
        
        function extendToSurface(point, oblateness) {
            const x = point[0], y = point[1], z = point[2];
            const a = x*x + z*z + (y/oblateness)*(y/oblateness);
            if (a < 0.001) return [x, y, z];
            const s = 1.0 / Math.sqrt(a);
            return [x * s, y * s, z * s];
        }
        
        function createLinesForGroup(group, numLongitudes, oblateness) {
            while (group.children.length > 0) {
                const child = group.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                group.remove(child);
            }
            
            const L = group.userData.L;
            const allLines = group.userData.allLines;
            if (!allLines || allLines.length === 0) return;
            
            const totalLines = allLines.length;
            
            for (let i = 0; i < numLongitudes; i++) {
                const lineIndex = Math.floor((i * totalLines) / numLongitudes) % totalLines;
                const pointsData = allLines[lineIndex];
                
                if (pointsData && pointsData.length > 5) {
                    const positions = [];
                    
                    const startExt = extendToSurface(pointsData[0], oblateness);
                    positions.push(startExt[0], startExt[1], startExt[2]);
                    
                    for (const p of pointsData) {
                        positions.push(p[0], p[1], p[2]);
                    }
                    
                    const endExt = extendToSurface(pointsData[pointsData.length - 1], oblateness);
                    positions.push(endExt[0], endExt[1], endExt[2]);
                    
                    const geometry = new LineGeometry();
                    geometry.setPositions(positions);
                    
                    const maxL = L_SHELLS_LOADED[L_SHELLS_LOADED.length - 1] || 30;
                    const t = Math.min((L - 1.1) / (maxL - 1.1), 1.0);
                    const color = new THREE.Color();
                    color.setHSL(0.65 - t * 0.65, 1.0, 0.55);
                    
                    const material = new LineMaterial({
                        color: color,
                        linewidth: currentThickness,
                        resolution: new THREE.Vector2(window.innerWidth, window.innerHeight)
                    });
                    
                    const line = new Line2(geometry, material);
                    line.computeLineDistances();
                    group.add(line);
                }
            }
        }
        
        function updateLongitudes(numLongitudes) {
            currentLongitudes = numLongitudes;
            const oblateness = planetData?.oblateness || 1.0;
            fieldLineGroups.forEach((group) => {
                createLinesForGroup(group, numLongitudes, oblateness);
            });
        }
        
        function updateThickness(thickness) {
            currentThickness = thickness;
            fieldLineGroups.forEach((group) => {
                group.children.forEach(child => {
                    if (child.material && child.material.linewidth !== undefined) {
                        child.material.linewidth = thickness;
                    }
                });
            });
        }
        
        function updateVisibleFieldLines(targetL) {
            let closestL = null;
            let closestDist = Infinity;
            
            L_SHELLS_LOADED.forEach(L => {
                const dist = Math.abs(L - targetL);
                if (dist < closestDist) {
                    closestDist = dist;
                    closestL = L;
                }
            });
            
            fieldLineGroups.forEach((group, L) => {
                group.visible = (L === closestL);
            });
        }
        
        // Store flux tube data for each moon - using dedicated high-res moon_flux_tubes data
        // These are fixed in the magnetic field frame (rotate with planet)
        // The moon moves through them as it orbits
        // Data structure: moon_flux_tubes[moonIndex].radial_samples[radialIndex].lines[lonIndex]
        let fluxTubeData = [];  // Array of {radialSamples, numLons, currentIndex, line} per moon
        
        function createFluxTubes(data) {
            if (!data.moons || data.moons.length === 0) return;
            if (!data.moon_flux_tubes || data.moon_flux_tubes.length === 0) {
                console.log('No moon flux tube data found - using legacy l_shells');
                createFluxTubesLegacy(data);
                return;
            }
            
            data.moon_flux_tubes.forEach((moonFT, moonIndex) => {
                if (!moonFT || !moonFT.radial_samples || moonFT.radial_samples.length === 0) {
                    fluxTubeLines.push(null);
                    fluxTubeData.push(null);
                    return;
                }
                
                // Use the middle radial sample (closest to actual orbit)
                const midIndex = Math.floor(moonFT.radial_samples.length / 2);
                const primarySample = moonFT.radial_samples[midIndex];
                const numLines = primarySample.lines.length;
                
                console.log(`Moon ${moonFT.moon_name}: ${moonFT.radial_samples.length} radial samples, ${numLines} longitudes each`);
                
                // Create ONE Line2 object per moon - we'll update its geometry dynamically
                const firstValidLine = primarySample.lines.find(l => l && l.length >= 5);
                if (!firstValidLine) {
                    fluxTubeLines.push(null);
                    fluxTubeData.push(null);
                    return;
                }
                
                const positions = [];
                for (const p of firstValidLine) {
                    positions.push(p[0], p[1], p[2]);  // No scaling needed - data is already at correct L
                }
                
                const geometry = new LineGeometry();
                geometry.setPositions(positions);
                
                const material = new LineMaterial({
                    color: FLUX_TUBE_COLORS[moonIndex % FLUX_TUBE_COLORS.length],
                    linewidth: 4,
                    resolution: new THREE.Vector2(window.innerWidth, window.innerHeight),
                    transparent: true,
                    opacity: 0.9
                });
                
                const fluxTube = new Line2(geometry, material);
                fluxTube.computeLineDistances();
                fluxTube.visible = false;
                tiltGroup.add(fluxTube);
                
                fluxTubeLines.push(fluxTube);
                fluxTubeData.push({
                    radialSamples: moonFT.radial_samples,  // All radial samples
                    numLons: numLines,
                    currentLonIndex: -1,
                    currentRadialIndex: midIndex
                });
            });
        }
        
        // Legacy function for old data format without moon_flux_tubes
        function createFluxTubesLegacy(data) {
            data.moons.forEach((moon, moonIndex) => {
                const moonOrbit = moon.orbit_radius;
                let closestLData = null;
                let closestDist = Infinity;
                
                for (const lData of data.l_shells) {
                    const dist = Math.abs(lData.L - moonOrbit);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestLData = lData;
                    }
                }
                
                if (!closestLData || !closestLData.lines || closestLData.lines.length === 0) {
                    fluxTubeLines.push(null);
                    fluxTubeData.push(null);
                    return;
                }
                
                const scaleFactor = moonOrbit / closestLData.L;
                const firstValidLine = closestLData.lines.find(l => l && l.length >= 5);
                if (!firstValidLine) {
                    fluxTubeLines.push(null);
                    fluxTubeData.push(null);
                    return;
                }
                
                const positions = [];
                for (const p of firstValidLine) {
                    positions.push(p[0] * scaleFactor, p[1], p[2] * scaleFactor);
                }
                
                const geometry = new LineGeometry();
                geometry.setPositions(positions);
                
                const material = new LineMaterial({
                    color: FLUX_TUBE_COLORS[moonIndex % FLUX_TUBE_COLORS.length],
                    linewidth: 4,
                    resolution: new THREE.Vector2(window.innerWidth, window.innerHeight),
                    transparent: true,
                    opacity: 0.9
                });
                
                const fluxTube = new Line2(geometry, material);
                fluxTube.computeLineDistances();
                fluxTube.visible = false;
                tiltGroup.add(fluxTube);
                
                fluxTubeLines.push(fluxTube);
                fluxTubeData.push({
                    rawLines: closestLData.lines,
                    scaleFactor: scaleFactor,
                    numLons: closestLData.lines.length,
                    currentLonIndex: -1,
                    isLegacy: true
                });
            });
        }
        
        // Update flux tubes: show the one the moon is currently in
        // Flux tubes are fixed in the planet's magnetic field frame
        // Moon position relative to field = moon orbital angle - planet rotation angle
        function updateFluxTubes() {
            if (!showFluxTube) {
                fluxTubeLines.forEach(ft => { 
                    if (ft) ft.visible = false; 
                });
                return;
            }
            
            moonMeshes.forEach((moon, moonIndex) => {
                const fluxTube = fluxTubeLines[moonIndex];
                const ftData = fluxTubeData[moonIndex];
                if (!fluxTube || !ftData) return;
                
                fluxTube.visible = true;
                
                // Moon's angle in inertial frame
                const moonAngle = moonOrbitAngles[moonIndex];
                // Planet (and field) rotation in inertial frame
                const fieldAngle = planetRotation;
                // Moon's angle relative to the magnetic field (which flux tube it's in)
                let relativeAngle = moonAngle - fieldAngle;
                // Normalize to 0 to 2π
                relativeAngle = ((relativeAngle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
                
                // Convert to flux tube index (0 to numLons-1)
                const lonIndex = Math.floor(relativeAngle / (2 * Math.PI) * ftData.numLons) % ftData.numLons;
                
                // Only update geometry if the longitude index changed
                if (lonIndex !== ftData.currentLonIndex) {
                    ftData.currentLonIndex = lonIndex;
                    
                    let lineData;
                    if (ftData.isLegacy) {
                        // Legacy format: rawLines array with scaling
                        lineData = ftData.rawLines[lonIndex];
                        if (lineData && lineData.length >= 5) {
                            const positions = [];
                            for (const p of lineData) {
                                positions.push(p[0] * ftData.scaleFactor, p[1], p[2] * ftData.scaleFactor);
                            }
                            fluxTube.geometry.setPositions(positions);
                            fluxTube.computeLineDistances();
                        } else {
                            fluxTube.visible = false;
                        }
                    } else {
                        // New format: use the radial sample
                        const radialSample = ftData.radialSamples[ftData.currentRadialIndex];
                        let lineData = radialSample.lines[lonIndex];
                        
                        // If this longitude has no valid data, find nearest valid neighbor
                        if (!lineData || lineData.length < 5) {
                            // Search up to 10 degrees in each direction
                            for (let offset = 1; offset <= 10; offset++) {
                                const prevIdx = (lonIndex - offset + ftData.numLons) % ftData.numLons;
                                const nextIdx = (lonIndex + offset) % ftData.numLons;
                                
                                if (radialSample.lines[prevIdx] && radialSample.lines[prevIdx].length >= 5) {
                                    lineData = radialSample.lines[prevIdx];
                                    break;
                                }
                                if (radialSample.lines[nextIdx] && radialSample.lines[nextIdx].length >= 5) {
                                    lineData = radialSample.lines[nextIdx];
                                    break;
                                }
                            }
                        }
                        
                        if (lineData && lineData.length >= 5) {
                            const positions = [];
                            for (const p of lineData) {
                                positions.push(p[0], p[1], p[2]);
                            }
                            fluxTube.geometry.setPositions(positions);
                            fluxTube.computeLineDistances();
                            fluxTube.visible = true;
                        } else {
                            // No valid data found - hide the flux tube
                            fluxTube.visible = false;
                        }
                    }
                }
            });
        }
        
        // Aurora L-shells for each planet
        const AURORA_L_SHELLS = {
            earth: 6.0,
            jupiter: 50.0,
            saturn: 20.0
        };
        
        // Create aurora particles from field line footprints
        function createAurora(data) {
            // Only create aurora for Earth, Jupiter, Saturn
            if (!['earth', 'jupiter', 'saturn'].includes(currentPlanet)) return;
            
            const auroraL = AURORA_L_SHELLS[currentPlanet];
            const oblateness = data.oblateness || 1.0;
            
            // Find the L-shell closest to our aurora L
            let closestLData = null;
            let closestDist = Infinity;
            for (const lData of data.l_shells) {
                const dist = Math.abs(lData.L - auroraL);
                if (dist < closestDist) {
                    closestDist = dist;
                    closestLData = lData;
                }
            }
            
            if (!closestLData || !closestLData.lines) return;
            
            console.log(`Creating aurora at L=${closestLData.L} with ${closestLData.lines.length} field lines`);
            
            // Collect footprints from all field lines
            const particles = [];
            const colors = [];
            
            // Create longitude clumps for variable coverage
            const numClumps = 8 + Math.floor(Math.random() * 6);  // 8-13 clumps
            const clumpCenters = [];
            const clumpWidths = [];
            for (let c = 0; c < numClumps; c++) {
                clumpCenters.push(Math.random() * Math.PI * 2);
                clumpWidths.push(0.2 + Math.random() * 0.4);  // Variable width per clump
            }
            
            // Use ALL available field lines for full 360° coverage
            // For each field line, also create interpolated aurora between them
            const totalLines = closestLData.lines.length;
            // Resolution: 720 samples (0.5° steps) for moon flux tubes - no interpolation needed
            const targetLongitudes = 720;  // Target 720 samples for smooth aurora
            const interpolationFactor = Math.ceil(targetLongitudes / totalLines);
            
            for (let lonIdx = 0; lonIdx < totalLines * interpolationFactor; lonIdx++) {
                // Get the base field line and optionally interpolate
                const baseLineIdx = Math.floor(lonIdx / interpolationFactor) % totalLines;
                const nextLineIdx = (baseLineIdx + 1) % totalLines;
                const interpT = (lonIdx % interpolationFactor) / interpolationFactor;
                
                const linePoints = closestLData.lines[baseLineIdx];
                const nextLinePoints = closestLData.lines[nextLineIdx];
                if (!linePoints || linePoints.length < 5) continue;
                
                // Calculate longitude angle for clumping
                const firstPoint = linePoints[0];
                const baseLonAngle = Math.atan2(firstPoint[2], firstPoint[0]);
                const lonAngle = baseLonAngle + (interpT * Math.PI * 2 / totalLines);
                
                // Check if this longitude is in a clump (higher density) or gap (lower density)
                let inClump = false;
                let clumpIntensity = 0.3;  // Base intensity for gaps
                for (let c = 0; c < numClumps; c++) {
                    const dist = Math.abs(lonAngle - clumpCenters[c]);
                    const wrappedDist = Math.min(dist, Math.PI * 2 - dist);
                    if (wrappedDist < clumpWidths[c]) {
                        inClump = true;
                        clumpIntensity = Math.max(clumpIntensity, 1.0 - (wrappedDist / clumpWidths[c]) * 0.5);
                    }
                }
                
                // Get footprints at both ends of the field line
                // Interpolate between this line and next for more coverage
                const footprints = [];
                
                // Northern footprint (first point)
                const fp1 = linePoints[0];
                if (nextLinePoints && nextLinePoints.length > 0 && interpT > 0) {
                    const fp2 = nextLinePoints[0];
                    footprints.push([
                        fp1[0] * (1-interpT) + fp2[0] * interpT,
                        fp1[1] * (1-interpT) + fp2[1] * interpT,
                        fp1[2] * (1-interpT) + fp2[2] * interpT
                    ]);
                } else {
                    footprints.push(fp1);
                }
                
                // Southern footprint (last point)
                const sp1 = linePoints[linePoints.length - 1];
                if (nextLinePoints && nextLinePoints.length > 0 && interpT > 0) {
                    const sp2 = nextLinePoints[nextLinePoints.length - 1];
                    footprints.push([
                        sp1[0] * (1-interpT) + sp2[0] * interpT,
                        sp1[1] * (1-interpT) + sp2[1] * interpT,
                        sp1[2] * (1-interpT) + sp2[2] * interpT
                    ]);
                } else {
                    footprints.push(sp1);
                }
                
                footprints.forEach(fp => {
                    // Vary particle count based on clump intensity
                    const baseParticles = inClump ? 15 : 5;
                    const numParticles = Math.floor(baseParticles * clumpIntensity);
                    
                    for (let i = 0; i < numParticles; i++) {
                        // The footprint is already at r~1.0 (surface)
                        // For oblate planets, we need to account for oblateness
                        const basePos = new THREE.Vector3(fp[0], fp[1], fp[2]);
                        const r = basePos.length();
                        
                        // Normalize to get direction, then place at oblate surface
                        const dir = basePos.clone().normalize();
                        
                        // For oblate surface: x,z are equatorial, y is polar
                        // Surface is at: x²/1² + z²/1² + y²/oblateness² = 1
                        // Simplify: we scale y by oblateness to get unit sphere, find surface, scale back
                        const surfaceR = 1.0 / Math.sqrt(
                            dir.x * dir.x + dir.z * dir.z + (dir.y * dir.y) / (oblateness * oblateness)
                        );
                        
                        // Height distribution - planet-specific heights (reduced by 50%)
                        // Saturn: 0.015 planet radii, Earth/Jupiter: 0.025 planet radii
                        const maxHeight = currentPlanet === 'saturn' ? 0.015 : 0.025;
                        const heightFactor = Math.pow(Math.random(), 2.5);  // Concentrated at base
                        const height = heightFactor * maxHeight;
                        
                        // Position at oblate surface + height along radial direction
                        const pos = dir.clone().multiplyScalar(surfaceR + height);
                        
                        // Add tangential spread for fuzziness
                        const spread = 0.012;
                        pos.x += (Math.random() - 0.5) * spread;
                        pos.y += (Math.random() - 0.5) * spread;
                        pos.z += (Math.random() - 0.5) * spread;
                        
                        particles.push(pos.x, pos.y, pos.z);
                        
                        // Color variation
                        let r_col, g, b;
                        if (currentPlanet === 'saturn') {
                            const colorType = Math.random();
                            if (colorType < 0.5) {
                                r_col = 1.0; g = 0.1 + Math.random() * 0.2; b = 0.2 + Math.random() * 0.3;
                            } else if (colorType < 0.8) {
                                r_col = 1.0; g = 0.2 + Math.random() * 0.3; b = 0.4 + Math.random() * 0.3;
                            } else {
                                r_col = 0.8 + Math.random() * 0.2; g = 0.1; b = 0.5 + Math.random() * 0.4;
                            }
                        } else if (currentPlanet === 'jupiter') {
                            const colorType = Math.random();
                            if (colorType < 0.6) {
                                r_col = 0.4 + Math.random() * 0.2; g = 0.2; b = 0.8 + Math.random() * 0.2;
                            } else {
                                r_col = 0.6 + Math.random() * 0.2; g = 0.1; b = 0.9;
                            }
                        } else {
                            const colorType = Math.random();
                            if (colorType < 0.6) {
                                r_col = 0.2; g = 0.8 + Math.random() * 0.2; b = 0.3 + Math.random() * 0.2;
                            } else if (colorType < 0.85) {
                                r_col = 0.1; g = 0.6 + Math.random() * 0.2; b = 0.8 + Math.random() * 0.2;
                            } else {
                                r_col = 0.5 + Math.random() * 0.3; g = 0.2; b = 0.1;
                            }
                        }
                        colors.push(r_col, g, b);
                    }
                });
            }
            
            if (particles.length === 0) return;
            
            // Create particle system
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(particles, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.025,
                vertexColors: true,
                transparent: true,
                opacity: 0.4,  // Half opacity (was 0.8)
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            auroraParticles = new THREE.Points(geometry, material);
            auroraParticles.visible = showAurora;
            tiltGroup.add(auroraParticles);
            
            console.log(`Created aurora with ${particles.length / 3} particles`);
        }
        
        // Update aurora visibility
        function updateAurora() {
            if (auroraParticles) {
                auroraParticles.visible = showAurora;
            }
        }
        
        // Apply or remove axial tilt
        function applyAxialTilt() {
            if (!tiltGroup || !planetData) return;
            
            const axialTilt = planetData.axial_tilt || 0;
            const flipNorth = planetData.flip_north || false;
            
            if (showAxialTilt && axialTilt !== 0) {
                // Convert to radians and apply tilt around X axis
                let tiltRad = THREE.MathUtils.degToRad(axialTilt);
                tiltGroup.rotation.x = tiltRad;
                
                // For Uranus (flip_north=true), when tilted, flip the north arrow
                // because IAU north is actually on the "bottom" side after tilting
                if (northPoleArrow && flipNorth) {
                    northPoleArrow.rotation.z = Math.PI;  // Flip 180° so N points to true north
                }
            } else {
                tiltGroup.rotation.x = 0;
                // Reset north pole arrow when tilt is off
                if (northPoleArrow) {
                    northPoleArrow.rotation.z = 0;
                }
            }
        }
        
        async function loadPlanet(planetKey) {
            const loader = document.getElementById('loading');
            const loadingText = document.getElementById('loading-text');
            
            loader.style.display = 'block';
            document.getElementById('controls').style.display = 'none';
            loadingText.textContent = `Loading ${PLANET_CONFIGS[planetKey].name}...`;
            
            clearScene();
            currentPlanet = planetKey;
            
            try {
                const response = await fetch(`field_lines_${planetKey}.json`);
                planetData = await response.json();
                
                // Create a tilt group to hold all objects that get tilted together
                tiltGroup = new THREE.Group();
                scene.add(tiltGroup);
                
                createPlanet(planetData);
                createEquator(planetData);
                createNorthPoleArrow(planetData);
                createRings();
                createMoons(planetData);
                createFieldLines(planetData);
                createFluxTubes(planetData);
                createAurora(planetData);
                
                // Update UI
                document.getElementById('planet-title').textContent = `${planetData.planet} Magnetic Field`;
                document.getElementById('model-info').textContent = PLANET_CONFIGS[planetKey].modelInfo;
                
                // Show/hide controls based on planet
                document.getElementById('rings-group').style.display = planetKey === 'saturn' ? 'flex' : 'none';
                document.getElementById('moon-group').style.display = planetData.moons?.length > 0 ? 'flex' : 'none';
                document.getElementById('flux-tube-group').style.display = planetData.moons?.length > 0 ? 'flex' : 'none';
                document.getElementById('scale-note').style.display = planetData.moons?.length > 0 ? 'block' : 'none';
                
                // Show aurora toggle for Earth, Jupiter, Saturn
                const hasAurora = ['earth', 'jupiter', 'saturn'].includes(planetKey);
                document.getElementById('aurora-group').style.display = hasAurora ? 'flex' : 'none';
                document.getElementById('show-aurora').checked = showAurora;
                
                if (planetData.moons?.length > 0) {
                    const moonNames = planetData.moons.map(m => m.name).join('/');
                    document.getElementById('moon-label').textContent = `Show ${moonNames}`;
                    document.getElementById('flux-tube-label').textContent = `Show ${moonNames} Flux Tubes`;
                }
                
                // Update axial tilt label with planet's tilt value (IAU convention)
                const axialTilt = planetData.axial_tilt || 0;
                document.getElementById('tilt-label').textContent = `Show Axial Tilt (IAU; ${axialTilt.toFixed(1)}°)`;
                
                // Reset tilt checkbox state and apply tilt if checked
                document.getElementById('show-tilt').checked = showAxialTilt;
                applyAxialTilt();
                
                // Update dropdown to show current planet
                document.getElementById('planet-dropdown').value = planetKey;
                
                const maxL = L_SHELLS_LOADED[L_SHELLS_LOADED.length - 1] || 20;
                camera.position.set(maxL * 1.2, maxL * 0.7, maxL * 1.2);
                controls.update();
                
                loader.style.display = 'none';
                document.getElementById('controls').style.display = 'block';
                
            } catch (error) {
                console.error('Failed to load planet data:', error);
                loadingText.textContent = 'Error: ' + error.message;
            }
        }
        
        // Event listeners
        document.getElementById('planet-dropdown').addEventListener('change', (e) => {
            loadPlanet(e.target.value);
        });
        
        // Toggle controls visibility
        document.getElementById('toggle-controls').addEventListener('click', () => {
            const controls = document.getElementById('controls');
            const btn = document.getElementById('toggle-controls');
            if (controls.style.display === 'none' || controls.style.display === '') {
                controls.style.display = 'block';
                btn.textContent = 'Hide Controls';
            } else {
                controls.style.display = 'none';
                btn.textContent = 'Show Controls';
            }
        });
        
        document.getElementById('l-slider').addEventListener('input', (e) => {
            const idx = parseInt(e.target.value);
            const L = L_SHELLS_LOADED[idx] || 1.1;
            document.getElementById('l-value').textContent = L.toFixed(1);
            updateVisibleFieldLines(L);
        });
        
        document.getElementById('longitude-slider').addEventListener('input', (e) => {
            document.getElementById('longitude-value').textContent = e.target.value;
            updateLongitudes(parseInt(e.target.value));
        });
        
        document.getElementById('thickness-slider').addEventListener('input', (e) => {
            const thickness = parseFloat(e.target.value);
            document.getElementById('thickness-value').textContent = thickness.toFixed(1);
            updateThickness(thickness);
        });
        
        document.getElementById('show-rings').addEventListener('change', (e) => {
            if (ringsMesh) ringsMesh.visible = e.target.checked;
        });
        
        document.getElementById('show-moon').addEventListener('change', (e) => {
            moonMeshes.forEach(moon => moon.visible = e.target.checked);
        });
        
        document.getElementById('show-flux-tube').addEventListener('change', (e) => {
            showFluxTube = e.target.checked;
            updateFluxTubes();
        });
        
        document.getElementById('show-aurora').addEventListener('change', (e) => {
            showAurora = e.target.checked;
            updateAurora();
        });
        
        document.getElementById('auto-rotate').addEventListener('change', (e) => {
            autoRotate = e.target.checked;
            document.getElementById('speed-group').style.display = autoRotate ? 'block' : 'none';
        });
        
        document.getElementById('show-tilt').addEventListener('change', (e) => {
            showAxialTilt = e.target.checked;
            applyAxialTilt();
        });
        
        document.getElementById('speed-slider').addEventListener('input', (e) => {
            rotationSpeedMultiplier = parseFloat(e.target.value);
            document.getElementById('speed-value').textContent = rotationSpeedMultiplier.toFixed(1) + 'x';
        });
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            
            fieldLineGroups.forEach((group) => {
                group.children.forEach(child => {
                    if (child.material && child.material.resolution) {
                        child.material.resolution.set(window.innerWidth, window.innerHeight);
                    }
                });
            });
            
            fluxTubeLines.forEach(ftGroup => {
                if (ftGroup) {
                    ftGroup.children.forEach(child => {
                        if (child.material && child.material.resolution) {
                            child.material.resolution.set(window.innerWidth, window.innerHeight);
                        }
                    });
                }
            });
            
            moonOrbitLines.forEach(orbitLine => {
                if (orbitLine && orbitLine.material && orbitLine.material.resolution) {
                    orbitLine.material.resolution.set(window.innerWidth, window.innerHeight);
                }
            });
        });
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (autoRotate && planetData) {
                const rotationPeriod = planetData.rotation_period_hours;
                const planetSpeed = 0.003 * rotationSpeedMultiplier;
                planetRotation += planetSpeed;
                
                if (planetMesh) planetMesh.rotation.y = planetRotation;
                if (ringsMesh) ringsMesh.rotation.y = planetRotation;
                if (equatorLine) equatorLine.rotation.y = planetRotation;
                if (northPoleArrow) northPoleArrow.rotation.y = planetRotation;
                if (auroraParticles) auroraParticles.rotation.y = planetRotation;
                
                fieldLineGroups.forEach(group => {
                    group.rotation.y = planetRotation;
                });
                
                // Animate moons at their correct orbital speeds
                // Planet rotates at planetSpeed rad/frame
                // Moon orbital angular velocity = 2π / (period_hours * frames_per_hour)
                // But we want relative to planet: if planet period = 10h and moon = 40h,
                // then in 10h planet rotates 360° and moon rotates 90°
                // So moon angular velocity = planet angular velocity * (planet_period / moon_period)
                moonMeshes.forEach((moon, index) => {
                    const moonData = moon.userData;
                    // Moon orbital angular velocity relative to inertial frame
                    // If planet rotates 360° in rotationPeriod hours, 
                    // moon orbits 360° in moonData.period_hours
                    const orbitRatio = rotationPeriod / moonData.period_hours;
                    moonOrbitAngles[index] += planetSpeed * orbitRatio;
                    
                    // Update moon position
                    moon.position.x = moonData.orbit_radius * Math.cos(moonOrbitAngles[index]);
                    moon.position.z = moonData.orbit_radius * -Math.sin(moonOrbitAngles[index]);
                });
                
                // Update flux tubes to follow moons
                updateFluxTubes();
            }
            
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }
        
        // Start
        loadPlanet('earth');
        animate();
    </script>
</body>
</html>
